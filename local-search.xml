<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>React-diff算法</title>
    <link href="/2023/07/27/React-diff%E7%AE%97%E6%B3%95/"/>
    <url>/2023/07/27/React-diff%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h1><h2 id="使用虚拟dom的原因"><a href="#使用虚拟dom的原因" class="headerlink" title="使用虚拟dom的原因"></a>使用虚拟dom的原因</h2><p>在传统web应用中，往往会把数据的真实变化实时地更新到界面上，于是每次数据的微小变动都会引起DOM树的重新渲染。虚拟DOM的目的是将所有的操作累加起来，计算出所有的变化后，统一更新DOM一次性更新到界面上。</p><ul><li>同级对比</li><li>单个节点类型不同直接删除</li><li>标签类型相同，属性修改、位置挪动等实现复用</li></ul><p>使用<b>diff算法</b>找出更新前后v-dom的差异，diff算法三大策略：</p><ul><li><b>只对同级的react element进行对比</b>。如果一个DOM节点在前后两次更新中节约了层级，那么react不会复用它</li><li><b>两个不同类型（type字段不一样）的react element会产生不同的react element树</b>。例如元素div变为p，react会删除div及其子节点，并新建p和其子节点。</li><li>开发者可以通过key属性暗示哪些子元素在不同的渲染下保持稳定。</li></ul>]]></content>
    
    
    <categories>
      
      <category>React-diff算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React总结</title>
    <link href="/2023/07/25/React%20Fiber/"/>
    <url>/2023/07/25/React%20Fiber/</url>
    
    <content type="html"><![CDATA[<h1 id="React-Fiber"><a href="#React-Fiber" class="headerlink" title="React Fiber"></a>React Fiber</h1><p>react架构设计如下：<br>![1](&#x2F;images&#x2F;React Fiber&#x2F;1.png)</p><h2 id="为什么引入fiber-fiber解决了什么问题"><a href="#为什么引入fiber-fiber解决了什么问题" class="headerlink" title="为什么引入fiber(fiber解决了什么问题)"></a>为什么引入fiber(fiber解决了什么问题)</h2><p>React16之前，使用的是栈调和器，将所有v-dom全部遍历完成后，reconciler才能给出当前需要修改的真实dom的信息，并传递给renderer，进行渲染。<br>带来的问题是：这个过程是<b>不可中断</b>的，如果需要渲染的组件比较大，执行栈太深，js执行会占据主线程时间较长，会导致页面响应度变差。为了解决这个问题，react16引入了fiber，使得reconciler阶段可中断，适当的让出CPU执行权移交给浏览器，这样浏览器能更及时的响应用户的交互.</p><ul><li>react16之前<ul><li>调和器（stack reconciler）：找出前后两个虚拟dom数的差异（<b>diff算法</b>）</li><li>渲染器（renderer）：将差异更新到dom树并渲染更新界面</li></ul></li><li>react16之后<ul><li><b>调度器（schedule）：对组件渲染任务进行优先级排序，优先调度高优任务（16新增）</b></li><li>调和器（fiber reconciler）：找出前后两个虚拟dom数的差异（<b>diff算法</b>）</li><li>渲染器（renderer）：将差异更新到dom树并渲染更新界面<br>16之后，Fiber调和器代替了栈调和器，会利用调度器来帮忙处理渲染&#x2F;更新的工作。此外，因为fiber后，原来的react element tree有了一颗对应的fiber node tree。在diff两棵react element tree的差异时，Fiber调和器会基于fiber node tree来使用diff算法，通过 fiber node 的 return、child、sibling 属性能更方便的遍历 fiber node tree，从而更高效地完成 diff 算法。</li></ul></li></ul><h1 id="什么是fiber"><a href="#什么是fiber" class="headerlink" title="什么是fiber"></a>什么是fiber</h1><ul><li><p>一种更加精密的<b>并发处理机制</b><br>![2](&#x2F;images&#x2F;React Fiber&#x2F;2.png)</p></li><li><p>一种通过<b>链表</b>构成的数据结构<br>![3](&#x2F;images&#x2F;React Fiber&#x2F;3.png)</p></li></ul><p>Fiber的主要目标就是使React能充分调度，Fiber调度的优点</p><ul><li>能把可中断的任务切片处理</li><li>能调整任务优先级，重置并复用任务</li><li>可以在父子组件任务间前进后退切换任务</li><li>render方法可以返回多个元素</li><li>支持异常边界处理<br>为了实现以上功能，我们需要将任务分解成若干个单元。某种意义上，这就是1个fiber，1个fiber代表了任务的1个执行单元。<br>每次执行完一个单元，React就会检查现在还剩多少时间，没有时间就将控制权主动交换给浏览器，该方式类似与浏览器提供的requestIdleCallback Api。含义就是让浏览器有空的时候执行一下我们给的回调，这个回调会传入一个时间，该时间就是浏览器分配给我们的可用时间。</li></ul><h2 id="Fiber运行的关键因素"><a href="#Fiber运行的关键因素" class="headerlink" title="Fiber运行的关键因素"></a>Fiber运行的关键因素</h2><ul><li><p>fiber node<br>![4](&#x2F;images&#x2F;React Fiber&#x2F;4.png)</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs wren">&#123;<br>    <span class="hljs-comment">// 结构信息</span><br>    <span class="hljs-keyword">return</span>: <span class="hljs-title class_">Fiber</span> <span class="hljs-operator">|</span> <span class="hljs-literal">null</span>, <span class="hljs-comment">// 一般指向父Fiber节点</span><br>    <span class="hljs-variable">child</span>: <span class="hljs-title class_">Fiber</span> <span class="hljs-operator">|</span> <span class="hljs-literal">null</span>, <span class="hljs-comment">// 第一个子Fiber</span><br>    <span class="hljs-variable">sibling</span>: <span class="hljs-title class_">Fiber</span> <span class="hljs-operator">|</span> <span class="hljs-literal">null</span>, <span class="hljs-comment">// 下一个兄弟Fiber</span><br>    <span class="hljs-variable">key</span>: <span class="hljs-literal">null</span> <span class="hljs-operator">|</span> <span class="hljs-variable">string</span>, <span class="hljs-comment">// 唯一标识符</span><br>    <span class="hljs-comment">// 节点的类型信息</span><br>    <span class="hljs-variable">tag</span>: <span class="hljs-title class_">WorkTag</span>, <span class="hljs-comment">// 当前节点的没醒，比如FunctionComponent、ClassComponent等，定义fiber操作的类型</span><br>    <span class="hljs-variable">type</span>: <span class="hljs-variable">any</span>, <span class="hljs-comment">// 节点的具体类型。对于类数组，它指向构造函数；对于dom元素，它指向HTML TAG</span><br>    <span class="hljs-comment">// 节点的状态信息</span><br>    <span class="hljs-variable">stateNode</span>: <span class="hljs-variable">any</span>, 若当前<span class="hljs-variable">fiber</span>节点是<span class="hljs-variable">dom</span>元素，则对应真实<span class="hljs-variable">dom</span>；若是函数组件，则为<span class="hljs-literal">null</span>；若是<span class="hljs-keyword">class</span>组件，则为<span class="hljs-keyword">class</span>初始化出来的实例；若为<span class="hljs-variable">host</span>组件，即是树的根节点<span class="hljs-title class_">FiberRootNode</span><br>    <span class="hljs-variable">pengdingProps</span>: <span class="hljs-title class_">Object</span> <span class="hljs-operator">|</span> <span class="hljs-literal">null</span>, 待处理的<span class="hljs-variable">props</span><br>    <span class="hljs-variable">memorizedProps</span>: <span class="hljs-title class_">Object</span> <span class="hljs-operator">|</span> <span class="hljs-literal">null</span>, 上一次渲染的<span class="hljs-variable">propos</span><br>    <span class="hljs-variable">memorizedState</span>: <span class="hljs-title class_">Object</span> <span class="hljs-operator">|</span> <span class="hljs-literal">null</span>, 上一次渲染的<span class="hljs-variable">state</span><br>    <span class="hljs-comment">// 副作用</span><br>    <span class="hljs-variable">effectTag</span>: 当前节点的副作用类型，如节点更新（<span class="hljs-title class_">Update</span>）、删除（<span class="hljs-title class_">Deletion</span>）、替换(<span class="hljs-title class_">Placement</span>)<br>    <span class="hljs-variable">firstEffect</span>: <br>    <span class="hljs-variable">lastEffect</span>:<br>    <span class="hljs-variable">nextEffect</span>: <span class="hljs-title class_">Fiber</span> <span class="hljs-operator">|</span> <span class="hljs-literal">null</span>, <span class="hljs-comment">// 指向下一个副作用节点的指针</span><br>    <span class="hljs-variable">updateQueue</span>: <span class="hljs-variable">mixed</span>, <span class="hljs-comment">// 用于状态更新，回调函数，DOM更新的队列</span><br>    <span class="hljs-comment">// 替身</span><br>    <span class="hljs-variable">alternate</span>: <span class="hljs-title class_">React</span>在<span class="hljs-title class_">Reconciliation</span>过程中会构建一颗新的树（<span class="hljs-title class_">WorkInProgress</span>树，<span class="hljs-variable">WIP</span>树），可以认为是一颗表示当前工作进度的树。还有一颗表示一渲染界面的旧树（<span class="hljs-title class_">Current</span> <span class="hljs-title class_">Fiber</span> <span class="hljs-title class_">Tree</span>，<span class="hljs-title class_">React</span>就是一边和旧树对比，一遍构建<span class="hljs-variable">WIP</span>树的。<span class="hljs-variable">alternate</span>指向旧树的同等节点）<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Fiber Node就是通过return、child、sibling这三个属性，将Fiber Node连接成Fiber Tree。<br>![5](&#x2F;images&#x2F;React Fiber&#x2F;5.png)</p></li><li><p>Effect List</p><ul><li>Side Effect：React组件接受props或者内部state改变以及执行生命周期等，<b>对DOM结构产生了影响的行为</b>，统称为side effect（副作用），每个节点的副作用会对应存储到节点的updateQueue属性中</li><li>Effect List：有些node有side effect需要处理，有些没有。为了避免遍历整个树节点，加快处理速度，将需要处理的node通过effect list串联起来，该链表通过前面说过的fiber node的firstEffect、lastEffect、nextEffect三个属性来维护。</li></ul></li></ul><h2 id="fiber运行过程"><a href="#fiber运行过程" class="headerlink" title="fiber运行过程"></a>fiber运行过程</h2><p>主要包括render和commit两个过程：</p><ul><li>render：找出所有节点的变更，这个过程<b>可中断</b></li><li>commit：更新所有节点的变更，这个过程<b>不可中断</b></li></ul><h3 id="render过程"><a href="#render过程" class="headerlink" title="render过程"></a>render过程</h3><ul><li><ol><li>使用diff算法找到v-dom的差异（新增、修改、移动等），并将每个节点需要处理的side effect当做一个work记录在fiber node的updateQueue属性中</li></ol></li><li><ol start="2"><li>将需要处理side efect的fiber node通过链表的形式存储起来，生成effect list</li></ol></li><li><ol start="3"><li>通过当前的fiber tree复制一份workInProgress tree，进入commit阶段</li></ol></li></ul><h3 id="commit过程"><a href="#commit过程" class="headerlink" title="commit过程"></a>commit过程</h3><ul><li>拿到render阶段提交过来的workInProgress tree，结合effect list，一次性将side effect处理完成。</li><li>所有的work执行都在workInProgress tree中进行，根据收集到的变更信息，调用相关方法完成视图的更新操作。</li></ul><h2 id="react渲染总结"><a href="#react渲染总结" class="headerlink" title="react渲染总结"></a>react渲染总结</h2><ul><li>element：通过babel&#x2F;react转换jsx，执行render生成(React.createElement)</li><li>v-dom tree：通过React.createElement执行后得到的React element就是虚拟节点。element代表一个v-dom节点，多个element构成v-dom tree</li><li>fiber tree：链式结构，每一个react element生成时都会对应生成一个fiber node，即每一个v-dom节点对应一个fiber node，多个fiber node构成fiber tree</li><li>side effect：所有改变dom的操作统称为副作用，由v-dom对比的差异产生</li><li>effect list：链式结构，副作用列表，存储每个存在副作用的fiber node</li><li>wordInProgress tree：fiber tree的副本，所有的fiber node的side effect都在wordInProgress tree上执行</li></ul><h1 id="fiber引申来的优化方向"><a href="#fiber引申来的优化方向" class="headerlink" title="fiber引申来的优化方向"></a>fiber引申来的优化方向</h1><ul><li>保持dom结构的稳定，map过程中绑定key</li><li>store数据粒度：如果数据的粒度太粗、划分不明确不精细，则会存在数据粗粒度更新的情况，整个数据节点引用更新了，依赖这个数据的组件都会重新渲染，即使其中一些组件只用到了该数据的一个字段，本来不必要重新渲染。</li><li>组件单一职责原则：组件高内聚低耦合，传入的props纯净，非该组件使用的数据不传入。</li><li>useMemo&#x2F;memo：对计算结果或者dom片段进行缓存，避免不必要的重复渲染。</li><li>组件按需加载（lazy import），按需渲染</li></ul><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p><a href="https://www.xiabingbao.com/post/react/jsx-element-fiber-rfztfs.html">https://www.xiabingbao.com/post/react/jsx-element-fiber-rfztfs.html</a><br>渲染中断相关：<a href="https://juejin.cn/post/7092419515748712456">https://juejin.cn/post/7092419515748712456</a></p>]]></content>
    
    
    <categories>
      
      <category>React Fiber</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>重排和重绘</title>
    <link href="/2023/07/15/%E9%87%8D%E6%8E%92%E5%92%8C%E9%87%8D%E7%BB%98(todo)/"/>
    <url>/2023/07/15/%E9%87%8D%E6%8E%92%E5%92%8C%E9%87%8D%E7%BB%98(todo)/</url>
    
    <content type="html"><![CDATA[<h1 id="https-juejin-cn-post-6844904083212468238"><a href="#https-juejin-cn-post-6844904083212468238" class="headerlink" title="https://juejin.cn/post/6844904083212468238"></a><a href="https://juejin.cn/post/6844904083212468238">https://juejin.cn/post/6844904083212468238</a></h1>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rollup</title>
    <link href="/2023/07/15/rollup(todo)/"/>
    <url>/2023/07/15/rollup(todo)/</url>
    
    <content type="html"><![CDATA[<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p><a href="https://zhuanlan.zhihu.com/p/486644411?utm_id=0">https://zhuanlan.zhihu.com/p/486644411?utm_id=0</a></p>]]></content>
    
    
    <categories>
      
      <category>工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack</title>
    <link href="/2023/07/12/webpack/"/>
    <url>/2023/07/12/webpack/</url>
    
    <content type="html"><![CDATA[<h1 id="webpack是什么"><a href="#webpack是什么" class="headerlink" title="webpack是什么"></a>webpack是什么</h1><p>类似一条生产线，要经历一系列处理流程后才能将源文件转化为输出结果。<br>这条生产线上的每个处理流程的职责都是单一的，多个流程之间存在依赖关系，只有完成当前处理后才能交给下一个流程去处理。</p><h1 id="webpack的重要性"><a href="#webpack的重要性" class="headerlink" title="webpack的重要性"></a>webpack的重要性</h1><ul><li>降低开发复杂度</li><li>模块化：复杂的程序细化为小文件</li><li>预处理：scss、less等css预处理器</li><li>可以使用类似于TypeScript这种在JavaScript基础上拓展的开发语言，编译时解析为浏览器能理解的语言</li></ul><h1 id="loader和plugin有什么区别"><a href="#loader和plugin有什么区别" class="headerlink" title="loader和plugin有什么区别"></a>loader和plugin有什么区别</h1><ul><li>loader：用于对模块源码的转化，loader描述了webpack如何处理非js模块，并且在build中引入这些依赖。loader可以将文件从不同的语言（如TypeScript）转换为JavaScript，有了loader，webpack才可以打包处理各种的扩展语言。</li><li>plugin：用于解决loader无法实现的其他事，从打包优化到压缩，到重新定义环境变量，可以处理不同的任务。通过在声明周期内注入不通的插件来扩展更多的能力。</li></ul><h1 id="loader的原理和实现"><a href="#loader的原理和实现" class="headerlink" title="loader的原理和实现"></a>loader的原理和实现</h1><blockquote><p>loader像一个翻译官，每个loader可以把资源转换成新的结果输出并传递给下一个loader，但最后一个loader必须返回JavaScript。<b>【浏览器只支持js代码，不支持其他扩展语言】</b></p></blockquote><p>loader数组的解析顺序：从右向左。因为webpack使用的是compose函数式编程方式。</p><p>实现loader的原则：</p><ul><li>单一职责</li><li>链式组合</li><li>模块化</li><li>无状态</li></ul><h1 id="plugin的实现原理"><a href="#plugin的实现原理" class="headerlink" title="plugin的实现原理"></a>plugin的实现原理</h1><blockquote><p>plugin是运行在webpack<b>打包</b>过程中的某段逻辑，它主要的作用是根据webpack提供的一些hooks来进行一些额外的操作，使得webpack更加灵活扩展。</p></blockquote><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p><a href="https://juejin.cn/post/6861784748491669511">https://juejin.cn/post/6861784748491669511</a></p>]]></content>
    
    
    <categories>
      
      <category>工程化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css布局</title>
    <link href="/2023/07/11/css%E5%B8%83%E5%B1%80/"/>
    <url>/2023/07/11/css%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="两栏布局"><a href="#两栏布局" class="headerlink" title="两栏布局"></a>两栏布局</h1><h1 id="三栏布局"><a href="#三栏布局" class="headerlink" title="三栏布局"></a>三栏布局</h1>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css3新特性</title>
    <link href="/2023/07/11/css3%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2023/07/11/css3%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><p>css3新增了一些属性选择器和伪类，主要如下所示：</p><table><thead><tr><th>选择器</th><th>实例</th><th>描述</th></tr></thead><tbody><tr><td>[attr~&#x3D;value]</td><td>a[class~&#x3D;’aaa’]</td><td>匹配class中含有aaa的a标签</td></tr><tr><td>[attr^&#x3D;value]</td><td>a[class^&#x3D;”box”]</td><td>匹配class开头为box的a标签</td></tr><tr><td>[attr$&#x3D;value]</td><td>a[class$&#x3D;”box”]</td><td>匹配class结尾为box的a标签</td></tr><tr><td>[attr*&#x3D;value]</td><td>a[class*&#x3D;”box”]</td><td>匹配class中出现过box的a标签</td></tr><tr><td>:first-of-type</td><td>a:first-of-type</td><td>匹配属于其父元素首个a标签的a标签</td></tr><tr><td>:last-of-type</td><td>a:last-of-type</td><td>匹配属于其父元素最后一个a标签的a标签</td></tr><tr><td>:only-of-type</td><td>a:only-of-type</td><td>匹配属于其父元素唯一一个a标签的a标签</td></tr><tr><td>:only-child</td><td>a:only-child</td><td>匹配属于其父元素唯一子元素的a标签</td></tr><tr><td>:nth-child(n)</td><td>a:nth-child(2)</td><td>匹配属于其父元素第二个子元素的a标签</td></tr><tr><td>:nth-last-child(n)</td><td>a:nth-last-child(2)</td><td>匹配属于其父元素倒数第二个子元素的a标签</td></tr><tr><td>:nth-of-type(n)</td><td>a:nth-of-type(2)</td><td>匹配属于其父元素第二个a标签的a标签</td></tr><tr><td>:nth-of-type(n)</td><td>a:nth-of-type(2)</td><td>匹配属于其父元素倒数第二个a标签的a标签</td></tr><tr><td>:last-child</td><td>a:last-child</td><td>匹配属于其父元素最后一个子元素的a标签</td></tr></tbody></table><h1 id="新样式"><a href="#新样式" class="headerlink" title="新样式"></a>新样式</h1><h2 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h2><p>css3新增了三个边框属性：</p><ul><li>box-radius：创建圆角边框</li><li>box-shadow：为元素添加阴影</li><li>border-image：使用图片来绘制边框</li></ul><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>css3新增了几个关于背景的属性：</p><ul><li>background-clip：用于设定背景颜色或者图片的覆盖范围，默认是覆盖到border，可以设置背景从border或者padding开始显示。</li><li>background-origin：用于设置背景图片的原点，默认是以padding的左上角为原点，可以设置为border或者content的左上角来作为原点。</li><li>background-size：用来调整背景图片的大小，主要用于设定图片本身。<ul><li>contain：缩小图片以适合元素（维持像素长宽比）</li><li>cover：扩展图片以填补元素（维持像素长宽比）</li><li>100px 100px：指定图片显示的大小</li><li>100% 100%：指定图片显示大小，百分比是相对包含元素的尺寸</li></ul></li><li>background-break：控制背景可以在几个不同的盒子里怎么显示</li></ul><h2 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h2><ul><li>word-wrap：文字换行<ul><li>normal：使用浏览器默认的换行</li><li>break-all：允许在单词内换行</li></ul></li><li>text-overflow：设置当前行超过指定容器的边界时如何显示<ul><li>clip：修剪文本</li><li>ellipsis：显示省略号来代表被修剪的文本</li></ul></li><li>text-shadow：可给文本设置阴影</li><li>text-decoration：支持对文本更深层次的渲染<ul><li>text-fill-color：设置文字内部填充颜色</li><li>text-stroke-color：设置文字边界填充颜色</li><li>text-stroke-width：设置文字边界宽度</li></ul></li></ul><h2 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h2><ul><li>rgba：rba颜色值，a透明度</li><li>hsla：h色相，s饱和度，l亮度，a透明度</li></ul><h1 id="过渡-transition"><a href="#过渡-transition" class="headerlink" title="过渡-transition"></a>过渡-transition</h1><p><code>transition</code>属性可以指定一个或多个css属性的过渡效果</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">transition</span>: css属性, 过渡时间, 效果曲线（默认ease）, 延迟时间(默认<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>多个属性之间用逗号分隔，必须规定两项内容：</p><ul><li>过渡效果</li><li>过渡时间</li></ul><h1 id="转换-transform"><a href="#转换-transform" class="headerlink" title="转换-transform"></a>转换-transform</h1><p><code>transform</code>属性允许旋转、缩放、倾斜或平移给定元素</p><ul><li>旋转：transform: rotate(20deg);</li><li>缩放：transform: scale(0.5);</li><li>倾斜：transform: skew(30deg, 20deg);</li><li>平移：transform: translate(50%, 50%);</li></ul><h1 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h1><ul><li>animation-name：动画名称</li><li>animation-duration：动画持续时间</li><li>animation-timing-function：动画时间函数</li><li>animation-delay：动画延迟时间</li><li>animation-iteration-count：动画执行次数，可以设置为一个整数，也可以设置为infinite：意思是无限循环</li><li>animation-direction：动画执行方向</li><li>animation-paly-state：动画播放状态</li><li>animation-fill-mode：动画填充模式</li></ul><h1 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h1><ul><li>线性渐变：linear-gradient<br>  示例：background-image: linear-gradient(30deg, red, blue);</li><li>径向渐变：radial-gradient<br>  示例：background-image: radial-gradient(30deg, red, blue);</li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li>flex布局</li><li>grid布局</li><li>媒体查询</li><li>混合模式</li><li>…</li></ul><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p><a href="https://github.com/febobo/web-interview/issues/106">https://github.com/febobo/web-interview/issues/106</a></p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css选择器和优先级</title>
    <link href="/2023/07/10/css%E9%80%89%E6%8B%A9%E5%99%A8%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    <url>/2023/07/10/css%E9%80%89%E6%8B%A9%E5%99%A8%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="css选择器"><a href="#css选择器" class="headerlink" title="css选择器"></a>css选择器</h1><p>css选择器分为以下几种：</p><ul><li>简单选择器</li><li>伪类</li><li>伪元素</li><li>属性选择器</li><li>组合器</li><li>多用选择器</li></ul><h2 id="简单选择器"><a href="#简单选择器" class="headerlink" title="简单选择器"></a>简单选择器</h2><ul><li><p>元素选择器：元素类型span…</p></li><li><p>类选择器：.classname</p></li><li><p>id选择器: #idname</p></li><li><p>通用选择器：*</p></li></ul><h2 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h2><p>一个css伪类是一个以冒号(:)作为前缀的关键字，一般是表示元素的<b>特定状态</b>。用于添加到指定的选择器后用于指定样式在特定状态下呈现。常见的伪类有：</p><ul><li>active</li><li>hover</li><li>disabled</li><li>any</li><li>checked</li><li>default</li><li>focus</li><li>required</li><li>last-child</li><li>last-of-type</li><li>not()</li><li>nth-child()</li><li>…</li></ul><h2 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h2><p>伪类和伪元素都是关键字，但伪元素前缀是两个冒号（::），同样是添加到选择器后，但是一般是用于指定某个元素的某个部分。常见的伪元素有：</p><ul><li>::before</li><li>::after</li><li>::first-line</li><li>::first-letter</li><li>::selection</li><li>::backdrop</li></ul><h1 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h1><p>属性选择器根据元素的 属性和属性值 来匹配元素，语法有方括号[]组成，其中包含属性名，后跟可选条件已匹配属性的值。属性选择器可以根据其匹配属性值的方式分为两类：</p><ul><li>存在和值属性选择器：尝试匹配精确的属性值<table><thead><tr><th>选择器</th><th>实例</th><th>描述</th></tr></thead><tbody><tr><td>[attr]</td><td>a[title]</td><td>匹配带有title的a标签</td></tr><tr><td>[attr&#x3D;value]</td><td>a[href&#x3D;’<a href="http://www.baidu.com&/#39;]">www.baidu.com&#39;]</a></td><td>匹配href为<a href="http://www.baidu.com的a标签/">www.baidu.com的a标签</a></td></tr><tr><td>[attr~&#x3D;value]</td><td>a[class~&#x3D;’aaa’]</td><td>匹配class中含有aaa的a标签</td></tr></tbody></table></li><li>子串值属性选择器：”伪正则选择器”，提供类似于正则的灵活匹配方式<table><thead><tr><th>选择器</th><th>实例</th><th>描述</th></tr></thead><tbody><tr><td>[attr</td><td>&#x3D;value]</td><td>aa[class^&#x3D;”box”]</td></tr><tr><td>[attr^&#x3D;value]</td><td>aa[class^&#x3D;”box”]</td><td>匹配class开头为box的a标签</td></tr><tr><td>[attr$&#x3D;value]</td><td>aa[class$&#x3D;”box”]</td><td>匹配class结尾为box的a标签</td></tr><tr><td>[attr*&#x3D;value]</td><td>aa[class*&#x3D;”box”]</td><td>匹配class中出现过box的a标签</td></tr></tbody></table></li></ul><h2 id="组合器"><a href="#组合器" class="headerlink" title="组合器"></a>组合器</h2><p>组合器允许将多个选择器组合在一起，有四种可用的类型：</p><ul><li>后代选择器（空格）：允许选择嵌套在另一个元素中的某个元素，不一定是直接后代，也可以是孙子</li><li>子选择器（&gt;）：允许选择一个元素的<b>直接子元素</b>，必须是直接子元素。</li><li>相邻兄弟选择器（+）：允许选择一个元素的<b>直接兄弟元素</b>（在同一层级，且后边相邻的元素）</li><li>通用兄弟选择器（~）：允许选择一个元素的<b>兄弟元素</b>（在同一层级，且在后面，但不一定就在旁边）。</li></ul><blockquote><p>注：相邻兄弟选择器和通用兄弟选择器只会<b>“向后”选择</b>，DOM结构靠前的兄弟元素不在选择范围内。</p></blockquote><h2 id="多用选择器"><a href="#多用选择器" class="headerlink" title="多用选择器"></a>多用选择器</h2><p>将以逗号分开的多个选择器放在一起，共同声明同一组css规则，以将这组css规则应用到这些选择器选择的所有元素。<br>例如： .calssname1, .calssname2</p><h1 id="css优先级"><a href="#css优先级" class="headerlink" title="css优先级"></a>css优先级</h1><p>css优先级受css样式权重影响，两个选择器同时作用在一个元素上时，权重高者生效。</p><p>权重记忆口诀：从0开始，一个行内元素+1000，一个id选择器+100，一个class选择器、属性选择器、伪类+10，一个元素选择器、伪元素+1，通配符+0；</p><p><img src="/images/css%E9%80%89%E6%8B%A9%E5%99%A8%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7/1.webp" alt="1"></p><ul><li>!important会提升样式优先级</li></ul><p>整体样式优先级：</p><ul><li>!important &gt; 行内样式 &gt; 内联样式、外联样式（id选择器 &gt; class选择器、属性选择器、伪类 &gt; 标签选择器、伪元素 &gt; 通配符）</li><li>内联样式和外联样式的优先级由加载顺序决定，后面加载的覆盖前面的生效</li></ul><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>css选择器：<a href="https://segmentfault.com/a/1190000013424772">https://segmentfault.com/a/1190000013424772</a><br>css优先级：<a href="https://zhuanlan.zhihu.com/p/41604775">https://zhuanlan.zhihu.com/p/41604775</a></p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flex布局</title>
    <link href="/2023/07/09/flex%E5%B8%83%E5%B1%80/"/>
    <url>/2023/07/09/flex%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>flex布局意为弹性布局，用来为盒状模型提供最大的灵活性。设置为flex布局后，子元素的float、clear、vertical-align属性将失效。</p><p>采用flex布局的元素，称为flex容器，它的所有子元素自动成为容器成员，称之为项目。<br><img src="/images/flex%E5%B8%83%E5%B1%80/1.png" alt="1"></p><p>容器默认存在两根轴：</p><ul><li>水平的主轴。主轴开始位置叫<code>main start</code>，主轴结束位置叫<code>main end</code></li><li>垂直的交叉轴。交叉轴的开始位置叫<code>cross start</code>，交叉轴结束位置叫<code>cross end</code><br>项目默认沿主轴排列，单个项目占据的主轴空间叫<code>main size</code>，占据的交叉轴空间叫<code>cross size</code>。</li></ul><h1 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h1><p>以下6个属性设置在容器上：</p><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul><h1 id="flex-durection"><a href="#flex-durection" class="headerlink" title="flex-durection"></a>flex-durection</h1><p><code>flex-direction</code>决定主轴的方向，即项目的排列方向。它可能有以下四个取值：</p><ul><li>row（默认值）：水平排列，起点在左端</li><li>row-reverse：水平排列，起点在右端</li><li>column：垂直排列，起点在上沿</li><li>column-reverse：垂直排列，起点在下沿</li></ul><h1 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h1><p><code>flex-wrap</code>属性定义如果一条轴线排列不下的情况，如果换行。它可能有一下三个取值：</p><ul><li>nowrap（默认值）：不换行</li><li>wrap：换行，第一行在上方，一行放不下往下面放第二行</li><li>wrap-reverse：换行，第一行在下方，一行放不下往上面放第二行</li></ul><h1 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h1><p><code>flex-grow</code>属性是<code>flex-direction</code>和<code>flex-wrap</code>的简写，默认<code>row nowrap</code>;</p><h1 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h1><p><code>jusitifu-conent</code>属性定义了项目在<b>主轴</b>上的对齐方式。</p><ul><li>flex-start（默认）：左对齐</li><li>flex-end：右对齐</li><li>center：居中对齐</li><li>space-between：两端对齐，项目之间的间距相等</li><li>space-around：每个项目两侧的间隔相等，项目之间的间隔比项目与边框的间隔大一倍。</li></ul><h1 id="align-itens"><a href="#align-itens" class="headerlink" title="align-itens"></a>align-itens</h1><p><code>align-items</code>属性定义了项目在<b>交叉轴</b>上的对齐方式。</p><ul><li>flex-start：交叉轴的起点对齐</li><li>flex-end：交叉轴的终点对齐</li><li>center：交叉轴的中点对齐</li><li>baseline：项目的第一行文字的基线对齐</li><li>stretch（默认）：如果项目没有设置高度或者auto，将占满整个容器的高度。</li></ul><h1 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h1><p><code>align-content</code>属性定义了多根轴线（多行）的对齐方式。如果项目只有一根轴线，则该属性不生效。</p><ul><li>flex-start：与交叉轴的起点对齐</li><li>flex-end：与交叉轴的终点对齐</li><li>center：与交叉轴的中点对齐</li><li>space-between：与交叉轴两端对齐，轴线之间的间距平均分布</li><li>space-around：每根轴线两侧的间隔相等，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li>stretch（默认）：轴线占满整个交叉轴</li></ul><h1 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h1><p>以下6个属性设置在项目上：</p><ul><li>order</li><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li><li>flex</li><li>align-self</li></ul><h1 id="order"><a href="#order" class="headerlink" title="order"></a>order</h1><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认都为0；</p><h1 id="flex-grow-1"><a href="#flex-grow-1" class="headerlink" title="flex-grow"></a>flex-grow</h1><p><code>flex-grow</code>属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p><ul><li>如果所有项目的flex-grow都为1，则他们将等分剩余空间。</li><li>如果一个项目的flex-grow为2，其余为1，则前者占据的剩余空间将比后者多一倍。</li></ul><h1 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h1><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不够时，该项目将缩小。</p><ul><li>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。</li><li>如果一个项目的flex-shrink为0，其他都为1，则空间不足时，前者不缩小，后者都会缩小。</li><li>负值对该属性无效。</li></ul><h1 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h1><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小(元素内容的大小，如果文案比较多，就会撑开)。</p><ul><li>可以设置成width属性一样的值，则项目将占据固定空间。</li></ul><h1 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h1><p><code>flex</code>属性是<code>flex-grow</code>，<code>flex-shrink</code>和<code>flex-basis</code>三者的简写，默认值为<code>0 1 auto</code>；该属性有两个快捷值：</p><ul><li>auto（1, 1, auto）</li><li>none（0, 0, auto）</li></ul><p>简写flex:<br><img src="/images/flex%E5%B8%83%E5%B1%80/2.png" alt="2"></p><h1 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h1><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖容器上设置的align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。该属性有6个取值，除了auto，其他都与align-items属性完全一致。</p><ul><li>flex-start</li><li>flex-end</li><li>center</li><li>baseline</li><li>stretch</li><li>auto</li></ul><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>阮一峰：<a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html">https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a><br>flex解决文本溢出：<a href="https://juejin.cn/post/7118267018918232072">https://juejin.cn/post/7118267018918232072</a><br>flex简写：<a href="https://juejin.cn/post/6961741136037675039">https://juejin.cn/post/6961741136037675039</a></p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BFC原理</title>
    <link href="/2023/07/09/BFC%E5%8E%9F%E7%90%86/"/>
    <url>/2023/07/09/BFC%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="常见定位方案"><a href="#常见定位方案" class="headerlink" title="常见定位方案"></a>常见定位方案</h1><h2 id="普通文档流"><a href="#普通文档流" class="headerlink" title="普通文档流"></a>普通文档流</h2><p>普通流中，元素按照其在HTML中的<b>先后位置至上而下布局</b>。这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行。<br>除非特别指定，否则所有元素默认都是普通流定位。</p><h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><p>在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。</p><h2 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h2><p>在绝对定位布局中，元素会整体脱离普通流，因为绝对定位元素不会对其兄弟元素造成影响，绝对定位元素具体位置由绝对定位的坐标决定。</p><h1 id="BFC概念"><a href="#BFC概念" class="headerlink" title="BFC概念"></a>BFC概念</h1><p>BFC(Block Formatting Contexts)是对页面中的一块渲染区域，有一套渲染规则，它决定了其子元素如何定位，以及和其他元素的关系和相互作用，它属于上述定位方案的<b>普通流</b>。</p><p><b>具有BFC特性的元素可以看作是隔离了的独立容器，容器里的元素不会在布局上影响到外面的元素，并且BFC具有普通容器所没有的一些特性。</b></p><h1 id="触发BFC"><a href="#触发BFC" class="headerlink" title="触发BFC"></a>触发BFC</h1><p>只有元素满足一下任一条件即可触发BFC特性：</p><ul><li>根元素</li><li>浮动元素：float除none以外的值</li><li>绝对定位元素：position: absolute&#x2F;fixed</li><li>display: flex &#x2F; grid&#x2F; table&#x2F; inline-block &#x2F; table-cells</li><li>overflow: visible以外的值（hidden &#x2F; auto &#x2F;scroll）</li></ul><h1 id="BFC特性及应用"><a href="#BFC特性及应用" class="headerlink" title="BFC特性及应用"></a>BFC特性及应用</h1><ul><li>同一个BFC下外边距会发生折叠<ul><li>想避免外边距折叠，可以将其放在不同的BFC容器内</li></ul></li><li>BFC可以包含浮动的元素<ul><li>浮动元素会脱离普通文档流，所以通常计算容器高度时不会包含容器内浮动元素的高度。如果想高度包含容器内的浮动元素，可以触发容器的BFC。</li></ul></li><li>BFC可以阻止元素被浮动元素覆盖<ul><li>浮动元素的效果类似与文字环绕，这种时候其实文字所在的元素有部分是被浮动元素覆盖的，只是文字不会被覆盖。如果我们避免被浮动元素覆盖，可以触发浮动元素的BFC特性。这个方法可以用来实现<b>两列自适应布局</b>。</li></ul></li></ul><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>参考：<a href="https://zhuanlan.zhihu.com/p/25321647">https://zhuanlan.zhihu.com/p/25321647</a></p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css盒模型</title>
    <link href="/2023/07/09/css%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/07/09/css%E7%9B%92%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><p>盒模型包括：元素内容（content），内边距（padding）、边框（border）、外边距（margin）四个要素。</p><h1 id="标准模型和IE模型"><a href="#标准模型和IE模型" class="headerlink" title="标准模型和IE模型"></a>标准模型和IE模型</h1><p>标准模型的元素宽度 width &#x3D; content<br>IE模型的元素宽度 width &#x3D; content + padding + border<br>高度计算相同</p><h1 id="css设置元素宽高"><a href="#css设置元素宽高" class="headerlink" title="css设置元素宽高"></a>css设置元素宽高</h1><p>通过css3的新属性 box-sizing:</p><ul><li>content-box：设置盒模型为标准模型</li><li>border-box：设置盒模型为IE模型</li></ul><h1 id="js获取盒模型对象的宽高"><a href="#js获取盒模型对象的宽高" class="headerlink" title="js获取盒模型对象的宽高"></a>js获取盒模型对象的宽高</h1><ul><li>dom.getBoundingClientRect().width&#x2F;height：获取渲染后的宽高</li></ul><h1 id="外边距折叠"><a href="#外边距折叠" class="headerlink" title="外边距折叠"></a>外边距折叠</h1><p>当两个盒子垂直外边距相遇时，他们将折叠成一个外边距，合并后的外边距的高度等于两个发生合并的外边距中高度更大的那个。</p><p>注意：只有<b>普通文档流</b>中块框的垂直外边距才会发生外边距合并，行内框、浮动框或绝对定位之间的外边距不会合并。</p><p>更多外边距折叠相关以及如何解决这种情况，请见BFC原理篇。</p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写汇总</title>
    <link href="/2023/07/06/%E6%89%8B%E5%86%99%E6%B1%87%E6%80%BB/"/>
    <url>/2023/07/06/%E6%89%8B%E5%86%99%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="6种继承"><a href="#6种继承" class="headerlink" title="6种继承"></a>6种继承</h1><h1 id="3种this"><a href="#3种this" class="headerlink" title="3种this"></a>3种this</h1><h1 id="手写new"><a href="#手写new" class="headerlink" title="手写new"></a>手写new</h1><h1 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h1><h1 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h1>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise</title>
    <link href="/2023/06/25/Promise/"/>
    <url>/2023/06/25/Promise/</url>
    
    <content type="html"><![CDATA[<p>Promise</p><h1 id="Promise基本概念"><a href="#Promise基本概念" class="headerlink" title="Promise基本概念"></a>Promise基本概念</h1><p>Promise: 一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作的结果）。</p><h2 id="Promise对象特点："><a href="#Promise对象特点：" class="headerlink" title="Promise对象特点："></a>Promise对象特点：</h2><ul><li><ol><li>对象的状态不受外界影响。一共有三种状态：<code>pending</code>进行中，<code>fulfilled</code>已成功，<code>rejected</code>已失败。只有异步操作的结果可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</li></ol></li><li><ol start="2"><li>一旦状态改变，就不会再变。Promise对象的状态改变只有两种情况：从<code>pengding</code>变成<code>fulfilled</code>或者从<code>pending</code>变成<code>rejected</code>。<br>这两种情况发生之后，状态就凝固了，不会再发生改变，会一直保持这个结果，称之为<code>resolved</code>。</li></ol></li></ul><h2 id="Promise缺点："><a href="#Promise缺点：" class="headerlink" title="Promise缺点："></a>Promise缺点：</h2><ul><li><ol><li>无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li></ol></li><li><ol start="2"><li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部</li></ol></li><li><ol start="3"><li>处于pending状态时，无法得知目前进展到哪一个阶段（刚开始或即将完成）</li></ol></li></ul><h1 id="Promise基本用法"><a href="#Promise基本用法" class="headerlink" title="Promise基本用法"></a>Promise基本用法</h1><ul><li><p>Promise构造函数接收一个函数作为参数，该函数的两个参数是<code>resolve</code>函数和<code>reject</code>函数，这两个函数有js引擎提供。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 异步操作成功 */</span>) &#123;<br>        <span class="hljs-title function_">resolve</span>(value);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">reject</span>(error);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>Promise实例生成以后，可以用then方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数。</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">promise</span>.<span class="hljs-property">then</span>((<span class="hljs-title function_">function</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-comment">// handle success</span><br>&#125;), (<span class="hljs-title function_">function</span>(<span class="hljs-params">error</span>) &#123;<br>    <span class="hljs-comment">// handle error</span><br>&#125;));<br></code></pre></td></tr></table></figure></li><li><p>当resolve函数的参数也是一个Promise时，即一个异步操作的结果是返回另一个异步操作，如下例，这个时候p2的状态由p1的状态决定。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const p1 = <span class="hljs-keyword">new</span> Promise(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>    steTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        reject(<span class="hljs-keyword">new</span> Error(<span class="hljs-string">&#x27;fail&#x27;</span>), <span class="hljs-number">3000</span>);<br>    &#125;);<br>&#125;);<br><br>const p2 = <span class="hljs-keyword">new</span> Promise(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        resolve(p1);<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;)<br><br>p2.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    cosnole.<span class="hljs-built_in">log</span>(res);<br>&#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(err);<br>&#125;);<br></code></pre></td></tr></table></figure><p>最终打印出p1的结果：Error: fail</p></li></ul><h2 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h2><ul><li>then方法是Promise实例添加状态改变时的回调函数，接收两个函数作为参数，第一个参数是resolve状态的回调函数，第二个是reject状态的回调函数。</li><li>then方法返回的是一个新的promise实例，因此可以使用<code>链式调用</code>。</li></ul><h2 id="Promise-prototype-catch"><a href="#Promise-prototype-catch" class="headerlink" title="Promise.prototype.catch()"></a>Promise.prototype.catch()</h2><ul><li>catch方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时（reject等同于抛出错误）的回调函数。</li><li>Promise对象的错误具有<code>『冒泡』性质</code>，会一直向后传递，直到被捕获为止。</li><li>如果没有使用catch方法指定错误处理的回调函数，Promise对象抛的错误不会传递到外层代码。</li><li>catch()方法返回的还是一个Promise对象，后面还可以接着调用then方法。</li></ul><blockquote><p>catch和then的第二个方法有什么区别？<br>then的第二个方法只有在Promise实例是reject状态时才会调用，如果第一个方法中抛出错误则无法捕获。所以推荐使用promise.then().catch()的写法，既可以捕获reject状态，也可以捕获then方法中抛出来的错误。</p></blockquote><h2 id="Promise-prototype-finally"><a href="#Promise-prototype-finally" class="headerlink" title="Promise.prototype.finally()"></a>Promise.prototype.finally()</h2><ul><li>finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。</li><li>finally方法的回调函数不接受任何参数，这代表无法知道前面的Promise状态到底是fulfilled还是rejected，也表明finally方法里面的操作应该是与状态无关的。<br>实现：<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart">Promise.Prototype.<span class="hljs-keyword">finally</span>(callback =&gt; &#123;<br>    <span class="hljs-keyword">const</span> p = <span class="hljs-keyword">this</span>.constructor;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then(<br>        value =&gt; p.resolve(callback().then(() =&gt; value)),<br>        err =&gt; p.reject(callback().then() =&gt; &#123;<span class="hljs-keyword">throw</span> err&#125;)<br>    );<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul><h2 id="Promise-prototype-all"><a href="#Promise-prototype-all" class="headerlink" title="Promise.prototype.all()"></a>Promise.prototype.all()</h2><ul><li>all方法用于将多个Promise实例包装成一个新的Promise实例。该方法接收一个数组作为参数，数组每一项都是Promise实例，如果不是，则会调用Promise.resolve方法将参数转为Promise实例。</li><li>all方法接受的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例。</li><li>Promise.all()的状态由几个Promise实例共同决定。一共两种情况：<ul><li><ol><li><b>每个实例的状态都变成fulfilled，则Promise.all的状态也是fulfilled。此时每个实例的返回值会组成一个数组，传递给Promise.all的回调函数。</b></li></ol></li><li><ol start="2"><li><b>只要有一个实例被rejected，Promise.all的状态就会变成rejected。此时第一个被reject的实例的返回值，会传递给Promise.all的回调函数</b></li></ol></li></ul></li><li>如果这几个Promise实例，自己定义了catch方法，那么它一旦被rejected，并不会被触发Promise.all()的catch方法。</li></ul><h2 id="Promise-prototype-race"><a href="#Promise-prototype-race" class="headerlink" title="Promise.prototype.race()"></a>Promise.prototype.race()</h2><ul><li>race方法同样是将多个Promise包装成一个新的Promise实例。该方法，<b>只要有一个实例的状态发生改变，Promise.race的状态也就跟着改变。这个率先改变的Promise实例的返回值，会传递给Promise.race的回调函数。</b></li></ul><h2 id="Promise-prototype-any"><a href="#Promise-prototype-any" class="headerlink" title="Promise.prototype.any()"></a>Promise.prototype.any()</h2><ul><li>race方法同样是将多个Promise包装成一个新的Promise实例。该方法，<b>只要Promise实例有一个变成fulfilled状态，Promise.any就会变成fulfilled状态，该实例的返回值会传递给Promise.any的回调函数；如果所有实例都是rejected状态，Promise.any就会变成rejected状态，此时会抛出一个AggregateError错误，该对象的errors是一个数组，包含了每个实例的错误。</b></li></ul><h2 id="Promise-prototype-allSettled"><a href="#Promise-prototype-allSettled" class="headerlink" title="Promise.prototype.allSettled()"></a>Promise.prototype.allSettled()</h2><ul><li>allSettled方法用来确定一组Promise实例是否都结束了，不管其是成功还是失败。<br>该方法，<b>只有等到每个Promise实例的状态都发生了改变之后，Promise.allSettled的状态才会发生改变。</b></li><li><b>Promise.allSettled的状态一旦发生变更，状态只会变成fulfilled，不会变成reject。它的回调函数收到的参数是数组，数组每一项是一个对象，其结构固定为两个键值对，两个键分别为</b><ul><li>status（表示对应实例的状态，取值固定为fulfilled或者rejected）</li><li>value或reason（表示对应实例的返回值，对应实例成功时key为value，失败时为reason）<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 异步操作成功时<br>&#123;status: <span class="hljs-string">&#x27;fulfilled&#x27;</span>, value: res&#125;<br><span class="hljs-regexp">//</span> 异步操作失败时<br>&#123;status: <span class="hljs-string">&#x27;rejected&#x27;</span>, reason: reason&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve()"></a>Promise.resolve()</h2><ul><li>该方法可以将现有对象转为Promise对象，其状态分如下情况：<ul><li>参数为Promise实例时，Promise.resolve(params)仍然返回这个实例</li><li>参数为thenable对象，Promise.resolve(params)将该对象转为Promsie对象，且立即调用then方法</li><li>其他情况会返回一个状态为resolve的Promsie对象</li></ul></li></ul><h2 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject()"></a>Promise.reject()</h2><ul><li>该方法也会返回一个新的Promise对象，该实例的状态为rejected。</li></ul><h2 id="Promise-try"><a href="#Promise-try" class="headerlink" title="Promise.try()"></a>Promise.try()</h2><ul><li>在不知道或者不想区分是同步函数还是异步函数的情况下，想用Promise来处理。<ul><li>则可以用Promise.try()方法，这样里面如果是<b>同步函数则会同步执行</b>，如果是<b>异步函数则会异步执行</b>，并且两种情况具有统一的api</li></ul></li></ul><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="加载图片"><a href="#加载图片" class="headerlink" title="加载图片"></a>加载图片</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">loadImg</span>(<span class="hljs-params">url</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>        <span class="hljs-keyword">let</span> img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();<br><br>        img.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-title function_">resolve</span>(img);<br>        &#125;;<br><br>        img.<span class="hljs-property">onerror</span> = <span class="hljs-title function_">funtion</span>(<span class="hljs-params">err</span>) &#123;<br>            <span class="hljs-title function_">reject</span>(err)<br>        &#125;;<br>        img.<span class="hljs-property">src</span> = url;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="进阶-Promise原理"><a href="#进阶-Promise原理" class="headerlink" title="进阶-Promise原理"></a>进阶-Promise原理</h1><h2 id="Promise手写"><a href="#Promise手写" class="headerlink" title="Promise手写"></a>Promise手写</h2><ul><li><ol><li>初始化Promise状态（pending）</li></ol></li><li><ol start="2"><li>立即执行Promise中传入的函数fn，将Promise内部resolve、reject函数作为参数传递给fn，按事件机制时机处理</li></ol></li><li><ol start="3"><li>执行then(…)注册回调处理数组（then方案可被同一个Promise调用多次）</li></ol></li><li><ol start="4"><li>Promise的关键是要保证，then方法转入的参数onFulfilled和onRejected，必须在then方法被调用的那一轮事件循环之后的新执行栈中执行。</li></ol></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">const</span> PENDING = <span class="hljs-string">&#x27;PENDING&#x27;</span>;<br><span class="hljs-keyword">const</span> FULFILLED = <span class="hljs-string">&#x27;FULFILLED&#x27;</span>;<br><span class="hljs-keyword">const</span> REJECTED = <span class="hljs-string">&#x27;REJECTED&#x27;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Promise</span> &#123;<br>    <span class="hljs-keyword">constructor</span>(executor) &#123;<br>        <span class="hljs-comment">// 默认状态为pending</span><br>        <span class="hljs-keyword">this</span>.state = PENDING;<br>        <span class="hljs-comment">// 存放成功状态的值，默认为undefined</span><br>        <span class="hljs-keyword">this</span>.value = undefined;<br>        <span class="hljs-comment">// 存放失败状态的值，默认为undefined</span><br>        <span class="hljs-keyword">this</span>.reson = undefined;<br>        <span class="hljs-comment">// 存放成功状态的回调</span><br>        <span class="hljs-keyword">this</span>.onResolveCallbacks = [];<br>        <span class="hljs-comment">// 存放失败状态的回调</span><br>        <span class="hljs-keyword">this</span>.onRejectedCallbacks = [];<br><br>        <span class="hljs-comment">// 调用此方法就是成功</span><br>        let resolve = value =&gt; &#123;<br>            <span class="hljs-comment">// 状态为pending才可以更新状态，防止executor中调用两次resolve/reject方法</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state === PENDING) &#123;<br>                <span class="hljs-keyword">this</span>.state = FULFILLED;<br>                <span class="hljs-keyword">this</span>.value = value;<br>                <span class="hljs-keyword">this</span>.onResolveCallbacks.forEach(fn =&gt; fn());<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 调用此方法就是失败</span><br>        let reject = reason =&gt; &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state === PENGDING) &#123;<br>                <span class="hljs-keyword">this</span>.state = REJECTED;<br>                <span class="hljs-keyword">this</span>.reason = reason;<br>                <span class="hljs-keyword">this</span>.onRejectedCallbacks.forEach(fn =&gt; fn());<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 立即执行，将resolve和reject函数传给使用者</span><br>            executor(resolve, reject);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (e) &#123;<br>            reject(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 包含一个then方法，并接收两个参数onFulFilled和onRejected</span><br>    then(onFulFilled, onRejected) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state === FULFILLED) &#123;<br>            onFulFilled(<span class="hljs-keyword">this</span>.value);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state === REJECTED) &#123;<br>            onRejected(<span class="hljs-keyword">this</span>.reason);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state === PENDING) &#123;<br>            <span class="hljs-keyword">this</span>.onResolveCallbacks.push(() =&gt; &#123;<br>                onFulFilled(<span class="hljs-keyword">this</span>.value);<br>            &#125;)<br>            <span class="hljs-keyword">this</span>.onRejectedCallbacks.push(() =&gt; &#123;<br>                onRejected(<span class="hljs-keyword">this</span>.reason);<br>            &#125;)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h1><ul><li><a href="https://juejin.cn/post/6850037281206566919">https://juejin.cn/post/6850037281206566919</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事件循环机制</title>
    <link href="/2023/06/25/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/06/25/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>事件循环机制</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数柯里化</title>
    <link href="/2023/06/21/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    <url>/2023/06/21/%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>函数柯里化</p><p>把接收<b>多个参数的一个函数</b>变成<b>一系列接收一个单一参数（最初函数的第一个参数）的函数</b>，并且返回接收余下的参数而且有返回结果的新函数。(<b>递归降解</b>)</p><ul><li>用途：实现<b>多参函数</b>。只传递函数一部分参数来调用它，让它返回一个函数去处理剩下的函数。</li></ul><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><ul><li>柯里化特性：延迟求值，需要用到js作用域来保存上一次传进来的参数（闭包）</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span><span class="hljs-params">(x, y)</span> &#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br>curryAdd(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>) = <span class="hljs-number">3</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span><span class="hljs-params">(fn, args)</span> &#123;<br>    <span class="hljs-keyword">if</span> (args.length &gt;= fn.length) &#123;<br>        <span class="hljs-keyword">return</span> fn(...args);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span><span class="hljs-params">(<span class="hljs-rest_arg">...arg2s</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> curry(fn, ...args, ...arg2s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现逻辑</p><ul><li>多次比较接受的参数总数和函数定义时的入参数量(<b>fn.length值为fn定义时的入参数量</b>)<ul><li>当接受的参数数量大于或等于被currying函数的传入参数量时，就返回计算结果</li><li>否则返回一个继续接受参数的函数<br>大致就是将参数存起来，参数数量凑够函数定义的入参数量了就执行函数，不够就继续下一轮</li></ul></li></ul><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><h2 id="参数复用"><a href="#参数复用" class="headerlink" title="参数复用"></a>参数复用</h2><h2 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h2><p>bind和箭头函数也能实现同样的功能</p><h1 id="currying的目的"><a href="#currying的目的" class="headerlink" title="currying的目的"></a>currying的目的</h1><ul><li><ol><li>为了让多参函数复用</li></ol></li><li><ol start="2"><li>函数式编程</li></ol></li></ul><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><ul><li><ol><li>性能差。如果我们只是想提前绑定参数，可以用bind来代替，性能比currying好</li></ol></li></ul><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p><a href="https://juejin.cn/post/6844903603266650125#comment">https://juejin.cn/post/6844903603266650125#comment</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>垃圾回收机制</title>
    <link href="/2023/06/17/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/06/17/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>垃圾回收机制</p><h1 id="为什么要回收"><a href="#为什么要回收" class="headerlink" title="为什么要回收"></a>为什么要回收</h1><p>V8引擎在执行js代码时，如果遇到函数，会为其创建函数执行上下文并压入执行上下文栈，函数的作用域包括了该函数中声明的所有变量。<br>当函数执行完毕之后，对应的执行上下文从栈中弹出，对应的函数作用随之被销毁，其包含的变量也会统一释放并被自动回收。<br>如果在作用域被销毁的时候，变量没有被自动回收，那么将持久占用内存，必然导致内存暴增。<br>一般来说，v8殷勤已经帮我们自动进行了内存的分配和管理，让我们能更专注与开发业务本身。但是我们需要了解这其中的原理，在写代码的过程中才能足够严谨，尽量不引发内存泄露。</p><h1 id="V8垃圾回收策略"><a href="#V8垃圾回收策略" class="headerlink" title="V8垃圾回收策略"></a>V8垃圾回收策略</h1><p><b>分代式垃圾回收机制</b>：根据对象的<b>存活时间</b>将内存的的垃圾回收进行不同的分代，然后对不同的分代采用不同的垃圾回收算法。</p><h2 id="v8内存结构"><a href="#v8内存结构" class="headerlink" title="v8内存结构"></a>v8内存结构</h2><ul><li>新生代：大多数对象的出生地、内存小且垃圾回收频繁。该区域分为两半：一半用于分配内存，一般用于在垃圾回收时将需要保留的对象复制过来。</li><li>老生代：新生代的对象存活一段时间后就会转移到老生代。老生代分为：老生代指针区、老生代数据区</li><li>大对象区</li><li>代码区</li><li>map区</li></ul><h2 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h2><p><b>scavenge算法</b>：将新生代内存一分为二，处于激活状态的称为From空间，处于未激活状态的称为To空间。两个空间，始终只有一个处于使用状态，另一个处于闲置状态。<br>程序中生命的对象首先会被分配到From空间，当进行垃圾回收时，如果From空间尚有存活对象，则会被复制到To空间进行保存，复制后From空间中未存活的对象全部被自动回收。<br>当复制完成后，From和To完成一次角色互换。该算法是典型的<b>牺牲空间换取时间</b>的算法。</p><ul><li>缺点：浪费了一半的内存用于复制</li><li>对象晋升：当一个对象经过多次复制之后依旧存活，那么会被认为是一个声明周期较长的对象，在下一次进行垃圾回收机制时，该对象会被直接转移到老生嗲中，这种从新生代转移到老生代的过程称之为晋升。<br>晋升条件主要2个：1.对象是否经历过一次scavenge算法 2.To空间的内存占比是否已经超过25%</li></ul><h2 id="老生代"><a href="#老生代" class="headerlink" title="老生代"></a>老生代</h2><p><b>标记清除算法和标记引用算法</b></p><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>分为标记和清除两个阶段。</p><ul><li>标记：标记阶段，从根节点出发遍历可以访问到的所有对象，通过<b>判断某个对象是否可以被访问到</b>，来标记存活的对象</li><li>清除：清除阶段中，对死亡的对象进行清除，释放所有非活动的内存块</li><li>缺点：清理的内存地址可能是不连续的，导致出现内存碎片的问题，导致要分配大对象而内存不足以分配，就会提前出发垃圾回收，而这种情况下的垃圾回收其实是不必要的，内存其实还有很多只是不连续，为了解决这个问题，有了标记整理算法。</li></ul><h3 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h3><ul><li>标记：标记阶段，从根节点出发遍历可以访问到的所有对象，通过<b>判断某个对象是否可以被访问到</b>，来标记存活的对象</li><li>整理：将活动的对象向内存的一段进行移动，移动完成后再清理掉边界外的全部内存</li></ul><h3 id="增量标记"><a href="#增量标记" class="headerlink" title="增量标记"></a>增量标记</h3><ul><li>原因：由于JS是单线程的，当进行垃圾回收时，会阻碍主线程的执行。（称为全停顿(stop-the-world)）标记阶段同样会阻碍主线程的执行，同时老生代中会保存大量的活动对象，若对所有的堆内存遍历一次势必会造成严重卡顿</li><li>原理：将原本需要一次性遍历堆内存的操作改为增量标记的方式，先标记堆内存中的一部分对象，然后暂停，将执行权重新交给JS主线程，待主线程任务执行完毕后再从原来暂停标记的地方继续标记，直到标记完整个堆内存。这个理念其实有点像React框架中的Fiber架构，只有在浏览器的空闲时间才会去遍历Fiber Tree执行对应的任务，否则延迟执行，尽可能少地影响主线程的任务，避免应用卡顿，提升应用性能</li></ul><h3 id="引用计数-旧，废除"><a href="#引用计数-旧，废除" class="headerlink" title="引用计数(旧，废除)"></a>引用计数(旧，废除)</h3><p>看对象是否还有被引用。如果没有指向该对象的引用，则搞对象会被视为垃圾并被垃圾回收。</p><ul><li>缺点：循环引用时，相互引用的变量都存在指向自身的引用，因此无法被回收，导致内存泄漏</li></ul><h1 id="避免内存泄露"><a href="#避免内存泄露" class="headerlink" title="避免内存泄露"></a>避免内存泄露</h1><ul><li>尽量少创建全局变量</li><li>手动清除定时器</li><li>少用闭包</li><li>清除dom引用</li><li>弱引用（WeakSet和WeakMap）</li></ul><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p><a href="https://juejin.cn/post/6844904016325902344">https://juejin.cn/post/6844904016325902344</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js数据类型和判断</title>
    <link href="/2023/06/06/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%88%A4%E6%96%AD/"/>
    <url>/2023/06/06/js%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%88%A4%E6%96%AD/</url>
    
    <content type="html"><![CDATA[<p>js数据类型和判断</p><p>见博客：<a href="https://www.cnblogs.com/jsunwang/p/13412887.html">https://www.cnblogs.com/jsunwang/p/13412887.html</a></p><p>typeof和instanceof的判断原理：<a href="https://juejin.cn/post/6844903613584654344">https://juejin.cn/post/6844903613584654344</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>测试经验</title>
    <link href="/2023/05/15/%E6%B5%8B%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    <url>/2023/05/15/%E6%B5%8B%E8%AF%95%E7%BB%8F%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<p>测试经验</p><h1 id="charles修改clientip"><a href="#charles修改clientip" class="headerlink" title="charles修改clientip"></a>charles修改clientip</h1><p>使用rewrite修改接口的入参和返回。</p><p><a href="https://blog.csdn.net/weixin_44330336/article/details/122843706">https://blog.csdn.net/weixin_44330336/article/details/122843706</a></p>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>闭包</title>
    <link href="/2023/04/29/%E9%97%AD%E5%8C%85/"/>
    <url>/2023/04/29/%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<p>闭包</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通过前面作用域和作用域链的学习，我们可以知道，JavaScript中作用域分为全局作用域和局部作用域，与之对应的就是全局变量和局部变量。</p><p>且js的的作用域链使得局部作用域内可以直接读取全局变量。但在局部作用域外部自然无法读取局部作用域内部的局部变量。<b>也即函数内部可以直接读取全局变量，但函数外部无法直接读取函数内的局部变量。</b></p><p>出于一些原因，我们有时候会需要拿到函数内的局部变量。如前面所说，正常情况下是拿不到的，但是在一种特殊情况下可以做到：那就是再函数内部，再定义一个函数。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">var</span> n = <span class="hljs-number">99</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> n; <span class="hljs-comment">// 999</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上例，由于f2在f1内部，此时f1内部的所有局部变量对f2都是可见的，但是反之不行。</p><p>但是既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，那我们就可以在f1外部访问f1内部的局部变量了。</p><h1 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h1><p>如上所示，这种<b>能够读取其他函数内部变量的函数我们称之为”闭包”，它一般是定义在一个函数内部的函数，充当将函数内部与函数外部连接起来的一座桥梁。</b></p><h1 id="闭包的使用场景"><a href="#闭包的使用场景" class="headerlink" title="闭包的使用场景"></a>闭包的使用场景</h1><p>闭包最大的用途有2个：</p><ul><li><ol><li>可以读取函数内部的局部变量</li></ol></li><li><ol start="2"><li>让函数内部的变量始终保持再内存当中</li></ol></li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">calcuNumber</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<br>    addNumber = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        n += <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">getNumber</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(n);<br>    &#125;<br>    <span class="hljs-keyword">return</span> getNumber;<br>&#125;<br><span class="hljs-keyword">var</span> getNumber = calcuNumber();<br>getNumber(); <span class="hljs-comment">// 999</span><br>addNumber();<br>getNumber(); <span class="hljs-comment">// 1000</span><br></code></pre></td></tr></table></figure><p>如上例，getNumber和addNumber都是闭包函数，只是getNumber为calcuNumber中返回的函数，addNumber为全局声明但在函数内部定义的一个函数，本质两个都是函数内部的函数，且能访问函数内部的变量。<br>且从两次getNumber的调用我们可以看出来，函数f1中的局部变量n一直保存在内存中，并没有再f1调用后被自动清楚。这是因为，calcuNumber是getNumber的父函数，而getNumber被赋予了一个全局变量，这导致getNumber始终在内存中，而getNumber的存在依赖于calcuNumber，所以calcuNumber也始终再内存中，不会在调用结束后被垃圾回收机制回收。</p><h1 id="闭包的原理"><a href="#闭包的原理" class="headerlink" title="闭包的原理"></a>闭包的原理</h1><p>作用域和作用域链相关</p><h1 id="使用闭包的注意事项"><a href="#使用闭包的注意事项" class="headerlink" title="使用闭包的注意事项"></a>使用闭包的注意事项</h1><ul><li><ol><li><b>注意不要随便改变父函数内部的变量值。</b> 由于闭包会在父函数外部改变父函数内部变量的值，所以容易错乱。<blockquote><p>解决方法： 把父函数当对象使用，把闭包当做父函数的公用方法，把内部变量当做父函数的<b>私有属性</b>。</p></blockquote></li></ol></li><li><ol start="2"><li><b>闭包可能导致性能问题和内存泄露。</b>由于闭包会使得函数中的变量都被保存在内存中，内存消耗会很大，所以不能滥用闭包，否则会造成网页的性能问题，还可能导致内存泄露。</li></ol></li></ul><blockquote><p>解决方法： 在退出函数之前，将不使用的全局变量删除。</p></blockquote><h1 id="匿名闭包与模块模式"><a href="#匿名闭包与模块模式" class="headerlink" title="匿名闭包与模块模式"></a>匿名闭包与模块模式</h1><h2 id="匿名闭包"><a href="#匿名闭包" class="headerlink" title="匿名闭包"></a>匿名闭包</h2><p>利用JavaScript<b>匿名函数</b>和<b>立即执行</b>的概念，创建一个匿名函数，并对其立即执行。所有函数内部代码都在闭包内，它可以作为一个独立模块，提供整个应用声明周期的私有和状态。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-name">function</span>() &#123;<br>    ...<br>&#125;())<br></code></pre></td></tr></table></figure><h2 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h2><p>使用匿名函数的返回值，输出到全局。一个基本的模块模式示例如下：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> counter = (<span class="hljs-keyword">function</span><span class="hljs-params">()</span> &#123;<br>    let i = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-keyword">get</span>: <span class="hljs-keyword">function</span> <span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> i;<br>        &#125;,<br>        <span class="hljs-keyword">set</span>: <span class="hljs-keyword">function</span><span class="hljs-params">(number)</span> &#123;<br>            i = number;<br>        &#125;,<br>        increment: <span class="hljs-keyword">function</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> ++i;<br>        &#125;<br>    &#125;<br>&#125;)();<br>counter.get(); <span class="hljs-comment">// 0</span><br>counter.set(<span class="hljs-number">3</span>);<br>counter.get(); <span class="hljs-comment">// 3</span><br>counter.increment(); <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><p>模块模式方法不仅简单还很厉害。通过非常少的代码，可以有效的利用方法和属性相关的命名，匿名函数闭包还维持了私有内部状态。在一个对象里，组织全部的模块代码最小化了全局变量的污染也创造了使用变量。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>阮一峰讲闭包：<a href="https://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html">https://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html</a><br>深入理解js模块模式：<a href="https://colobu.com/2014/09/23/JavaScript-Module-Pattern-In-Depth/">https://colobu.com/2014/09/23/JavaScript-Module-Pattern-In-Depth/</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>this指向</title>
    <link href="/2023/04/21/this%E6%8C%87%E5%90%91/"/>
    <url>/2023/04/21/this%E6%8C%87%E5%90%91/</url>
    
    <content type="html"><![CDATA[<p>this指向</p><p>由《执行上下文栈》我们可知JavaScript每执行一段可执行代码时，都会创建对应的执行上下文。</p><p>对于每个执行上下文，都有三个重要属性：</p><ul><li>变量对象</li><li>作用域链</li><li>this</li></ul><p>本篇主要介绍this。</p><h1 id="不同调用场景下的this"><a href="#不同调用场景下的this" class="headerlink" title="不同调用场景下的this"></a>不同调用场景下的this</h1><p>首先需要明确的是，不像函数作用域是在函数定义的时候就确定了，this的指向在函数定义的时候是无法确定的，只有函数执行的时候才能确定this到底指向谁。</p><p>在非箭头函数下，this想象调用其所在函数的对象，而且是离谁近就指向谁（此对于常规对象、原型链、getter&amp;setter等都适用）；构造函数下，this与被创建的新对象绑定；DOM事件中，this指向触发事件的元素；还有内联事件、延时函数、箭头函数等情况，我们分开展开以下讨论。</p><h1 id="全局环境"><a href="#全局环境" class="headerlink" title="全局环境"></a>全局环境</h1><p>在全局环境下，无论是否严格模式，this始终指向全局对象（window）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在浏览器中，全局对象为window对象</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> === <span class="hljs-variable language_">window</span>); <span class="hljs-comment">// true</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">document</span> === <span class="hljs-variable language_">window</span>); <span class="hljs-comment">// true</span><br><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = <span class="hljs-number">2</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">a</span>); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><h1 id="函数上下文调用中的this"><a href="#函数上下文调用中的this" class="headerlink" title="函数上下文调用中的this"></a>函数上下文调用中的this</h1><h2 id="函数直接调用"><a href="#函数直接调用" class="headerlink" title="函数直接调用"></a>函数直接调用</h2><p>普通函数内部的this分【严格模式】和【非严格模式】两种情况。</p><p>非严格模式下，this默认指向全局对象window</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">thisl</span><br>&#125;<br><br>console.log(f1() === window); // <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>严格模式下，this默认为undefined</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-string">&quot;use strict&quot;</span>;<br>    <span class="hljs-keyword">return</span> this;<br>&#125;<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(f2() === <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="对象中的this"><a href="#对象中的this" class="headerlink" title="对象中的this"></a>对象中的this</h2><p><b>对象内部方法的this指向调用这些方法的对象。</b>注意：</p><ol><li><p><b>函数的定义无法确定this的指向，this指向只与调用函数的对象有关。</b></p></li><li><p><b>多层嵌套的对象，内部方法的this指向离被调用函数最近的对象。</b></p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>,<br>    <span class="hljs-attr">b</span>: &#123;<br>        <span class="hljs-attr">a</span>: <span class="hljs-number">12</span>,<br>        <span class="hljs-attr">fn</span>: <span class="hljs-title function_">funtion</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>); <span class="hljs-comment">// 12</span><br>        &#125;<br>    &#125;<br>&#125;<br>o.<span class="hljs-property">b</span>.<span class="hljs-title function_">fn</span>();<br></code></pre></td></tr></table></figure><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> o = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>,<br>    <span class="hljs-attr">b</span>: &#123;<br>        <span class="hljs-attr">a</span>: <span class="hljs-number">12</span>,<br>        <span class="hljs-attr">fn</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.a); <span class="hljs-comment">// undefined</span><br>            <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this); <span class="hljs-comment">// window</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> j = o.b.fn;<br>j();<br></code></pre></td></tr></table></figure><p>第一个例子中的this指向离 被调用函数fn 最近的对象，也就是对象b，所以打印出来的this.a就是12.</p><p>第二个例子中，虽然函数fn是对象b的一个方法，但是在将fn赋值给j的时候并没有执行，被赋值后的j就是fn函数。而变量j是window的属性，所以当后面调用j()的时候指向的就是window。</p><h2 id="原型链中的this"><a href="#原型链中的this" class="headerlink" title="原型链中的this"></a>原型链中的this</h2><p><b>原型链中的方法的this仍然是指向调用它的对象。</b></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o = &#123;<br>    <span class="hljs-attr">f</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">var</span> p = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(o);<br>p.<span class="hljs-property">a</span> = <span class="hljs-number">1</span>;<br>p.<span class="hljs-property">b</span> = <span class="hljs-number">4</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-title function_">f</span>()); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p>上例中，虽然p中没有属性f，但是当在执行p.f()时，会查找p的原型链，找到f函数并执行，这个时候是p调用f函数。以上对于函数作为getter和setter时同样适用。</p><h2 id="构造函数中的this"><a href="#构造函数中的this" class="headerlink" title="构造函数中的this"></a>构造函数中的this</h2><p><b>构造函数的this与新创建的新对象绑定。</b></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"> &#123;</span><br><span class="hljs-params">    <span class="hljs-variable language_">this</span>.user = <span class="hljs-string">&#x27;jjj&#x27;</span>;</span><br><span class="hljs-params">&#125;</span>)<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">fn</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">user</span>); <span class="hljs-comment">// jjj</span><br></code></pre></td></tr></table></figure><p>这里为什么新创建的对象a能读到构造函数fn内的属性呢？这其实涉及到new关键字，我们搞清楚new关键字到底做了什么，就能理解了，接下来我们看一下new关键字做了什么。</p><h3 id="new关键字"><a href="#new关键字" class="headerlink" title="new关键字"></a>new关键字</h3><p>以以下这个构造函数为例:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(name, age)</span> &#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>    <span class="hljs-keyword">this</span>.age = age;<br>&#125;<br></code></pre></td></tr></table></figure><p>new关键字在创建实例对象时，主要经历了以下4个过程：</p><ul><li><ol><li>首先创建一个空对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br></code></pre></td></tr></table></figure><blockquote><p>创建对象的三种方式</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;&#125;;<br><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">let</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure></li></ol></li><li><ol start="2"><li>实例对象obj的隐式原型要与构造函数Person的显式原型指向相同<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">obj._proto_</span> = Person.prototype<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ol></li><li><ol start="3"><li>将构造函数Person内部的this与实例对象obj做绑定，并对构造函数内部的值做一个赋值操作。<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure></li></ol></li><li><ol start="4"><li>根据构造函数的返回值类型确定新创建的实例对象的具体值。若构造函数的返回值是引用类型（Object、Array、Function）的，那么我们新创建的实例对象就是该返回值；若返回值存在但不为引用类型，或者没有返回值(如上例)，那么新创建的对象就是构造函数实例。</li></ol></li></ul><p>通过了解new关键字实例化对象的过程，我们可以很清楚的知道为什么构造函数的this会与新创建的新对象绑定了。</p><h3 id="手写模拟实现new"><a href="#手写模拟实现new" class="headerlink" title="手写模拟实现new"></a>手写模拟实现new</h3><p>function myNew(fn, …args) {<br>    &#x2F;&#x2F; 1. 创建一个空对象<br>    var obj &#x3D; new Object();<br>    &#x2F;&#x2F; 2. 将新对象的隐式原型指向构造函数的显式原型<br>    obj.<strong>proto</strong> &#x3D; fn.prototype;<br>    &#x2F;&#x2F; 3. 将构造函数的this指向该对象<br>    const res &#x3D; fn.call(obj, …args);<br>    &#x2F;&#x2F; 4. 如果构造函数的返回值是对象，则实例化的返回对象就是这个对象；否则就返回新创建的构造函数实例对象<br>    if (typeof res &#x3D;&#x3D;&#x3D; ‘object’) {<br>        return res;<br>    }<br>    return obj;<br>}</p><h3 id="构造函数中有return时"><a href="#构造函数中有return时" class="headerlink" title="构造函数中有return时"></a>构造函数中有return时</h3><p>返回为对象</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>    this.user = <span class="hljs-string">&#x27;jjj&#x27;</span>;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">user</span>: <span class="hljs-string">&#x27;aaa&#x27;</span>&#125;;<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> fn();<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a.user); <span class="hljs-comment">// aaa</span><br></code></pre></td></tr></table></figure><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>    this.user = <span class="hljs-string">&#x27;jjj&#x27;</span>;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> fn();<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a.user); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>返回为函数</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>    this.user = <span class="hljs-string">&#x27;jjj&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;;<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> fn();<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a.user); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>返回为非引用类型</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>    this.user = <span class="hljs-string">&#x27;jjj&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// return undefined;</span><br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> fn();<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a.user); <span class="hljs-comment">// jjj</span><br></code></pre></td></tr></table></figure><p>这几个例子说明了new关键字在实例化对象时第4步所做的事。值得注意的一点时，虽然null也是对象，但如果构造函数返回了null，这个时候的this还是指向那个函数的实例，null比较特殊。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>    this.user = <span class="hljs-string">&#x27;jjj&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> fn();<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a.user); <span class="hljs-comment">// jjj</span><br></code></pre></td></tr></table></figure><h1 id="DOM事件处理函数"><a href="#DOM事件处理函数" class="headerlink" title="DOM事件处理函数"></a>DOM事件处理函数</h1><p>当函数被当作<b>监听事件处理函数</b>时，其this指向触发该事件的元素（<b>针对addEventListener事件</b>）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 被调用时，将关联的元素变成蓝色</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bluify</span>(<span class="hljs-params">e</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">//在控制台打印出所点击元素</span><br>  e.<span class="hljs-title function_">stopPropagation</span>();  <span class="hljs-comment">//阻止时间冒泡</span><br>  e.<span class="hljs-title function_">preventDefault</span>(); <span class="hljs-comment">//阻止元素的默认事件    </span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&#x27;#A5D9F3&#x27;</span>;<br>&#125;<br><span class="hljs-comment">// 获取对应元素进行监听</span><br><span class="hljs-keyword">var</span> el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElemenById</span>(<span class="hljs-string">&#x27;should-bluify&#x27;</span>);<br><br><span class="hljs-comment">// 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色</span><br>el.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, bluify, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><p>在以上例子中，作为监听事件处理函数的bluify函数中的this就指向el元素。</p><h1 id="内联事件"><a href="#内联事件" class="headerlink" title="内联事件"></a>内联事件</h1><p>内联事件中的this分两种情况：</p><ul><li><ol><li>当代码被内联处理函数调用时，它指向监听器所在的DOM元素</li></ol></li><li><ol start="2"><li>当代码被包括在函数内部执行时，其this指向等同于函数直接调用的情况，即非严格模式指向全局对象window，严格模式指向undefined。</li></ol></li></ul><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs hsp">&lt;<span class="hljs-keyword">button</span> <span class="hljs-keyword">onclick</span>=<span class="hljs-string">&quot;console.log(this);&quot;</span>&gt;show me&lt;/<span class="hljs-keyword">button</span>&gt; <span class="hljs-comment">// 打印出该button元素</span><br>&lt;<span class="hljs-keyword">button</span> <span class="hljs-keyword">onclick</span>=<span class="hljs-string">&quot;(function() &#123;console.log(this)&#125;)()&quot;</span>&gt;show inner this&lt;/<span class="hljs-keyword">button</span>&gt; <span class="hljs-comment">// 打印window对象</span><br>&lt;<span class="hljs-keyword">button</span> <span class="hljs-keyword">onclick</span>=<span class="hljs-string">&quot;(function() &#123;&quot;</span>use strict<span class="hljs-string">&quot;; console.log(this)()&#125;)&quot;</span>&gt;show inner this uer strict&lt;/<span class="hljs-keyword">button</span>&gt; <span class="hljs-comment">// 打印undefined</span><br><br></code></pre></td></tr></table></figure><h1 id="setTimeOut-amp-setInterval"><a href="#setTimeOut-amp-setInterval" class="headerlink" title="setTimeOut &amp; setInterval"></a>setTimeOut &amp; setInterval</h1><p>对于延时函数内部的回调函数的this指向全局对象window。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//默认情况下代码</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;  <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">0</span>;  <br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<span class="hljs-comment">// 打印出window对象</span><br>    &#125;, <span class="hljs-number">3000</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-comment">//3秒后返回 window 对象</span><br></code></pre></td></tr></table></figure><blockquote><p style="color: red">疑问？为什么如果在setTimeOut中打印this.a，能正确打印出来呢，this不是window对象吗</p></blockquote><p>当然也可以用过bing方法改变其内部函数的this指向</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//通过bind绑定</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;  <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">0</span>;  <br>    <span class="hljs-built_in">setTimeout</span>((<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<span class="hljs-comment">// 打印出Person对象</span><br>    &#125;).<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>), <span class="hljs-number">3000</span>);<br>&#125;<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(); <span class="hljs-comment">//3秒后返回构造函数新生成的对象 Person&#123;...&#125;</span><br></code></pre></td></tr></table></figure><h1 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h1><p>箭头函数不绑定this，它会捕获其所在的上下文的this值，作为自己的this值。需要注意的是：</p><ul><li><ol><li>call()、apply()、bing()方法对于箭头函数来说只是传入参数，对它的this毫无影响</li></ol></li><li><ol start="2"><li>考虑到箭头函数的this是词法层面的，可以忽略是否是严格模式对this的影响</li></ol></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;  <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">0</span>;  <br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// Person对象</span><br>    &#125;, <span class="hljs-number">3000</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;  <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">0</span>;  <br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// Window对象</span><br>    &#125;, <span class="hljs-number">3000</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br></code></pre></td></tr></table></figure><p>验证严格模式影响</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<span class="hljs-string">&#x27;use strict&#x27;</span>; <span class="hljs-keyword">return</span> this&#125;;<br><span class="hljs-keyword">var</span> p = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; <span class="hljs-keyword">return</span> this&#125;;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>,f() === window); <span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>,f() === p()); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>为什么说箭头函数的this是词法层面的呢？我们可以看以下的例子：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">var</span> obj = &#123;<br>  i: <span class="hljs-number">10</span>,<br>  b: () =&gt; console.log(this.i, this),<br>  c: function() &#123;<br>    console.log( this.i, this)<br>  &#125;<br>&#125;<br>obj.b();  // undefined window<span class="hljs-meta">&#123;...&#125;</span><br>obj.c();  // <span class="hljs-number">10</span> <span class="hljs-type">Object</span> <span class="hljs-meta">&#123;...&#125;</span><br></code></pre></td></tr></table></figure><p>我们可以看到obj.b()打印出来的this指向了window，这是因为指向了当前的执行上下文，捕获了当前上下文的this作为自己的this，而此时当前上下文的this就是window。</p><h1 id="改变this指向的方式"><a href="#改变this指向的方式" class="headerlink" title="改变this指向的方式"></a>改变this指向的方式</h1><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">Function</span>.<span class="hljs-keyword">call</span>(obj, arg1, arg2, ...)<br></code></pre></td></tr></table></figure><blockquote><p>注意点：</p></blockquote><ul><li><ol><li>调用call的对象必须是函数（fn）。</li></ol></li><li><ol start="2"><li>call的第一个参数，是一个对象。fn的调用者，将会指向这个对象，如果不传，默认为全局对象window.</li></ol></li><li><ol start="3"><li>从第二个参数开始，接受的任意个参数会影射到相应位置的fn的入参上。如果将所有参数作为数组传入，会作为一个整体映射到fn对应的第一个参数上。</li></ol></li></ul><p>手写：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">Function.prototype.myCall = <span class="hljs-keyword">function</span><span class="hljs-params">(context, <span class="hljs-rest_arg">...arguments</span>)</span> &#123;<br>    <span class="hljs-comment">// 如果context没传，或者为null/undefined之类的，置为指向window</span><br>    context = context || window;<br><br>    <span class="hljs-comment">// 如果传入的context不是对象，则置为对象</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> context !== <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>        context = Object(context);<br>    &#125;<br><br>    <span class="hljs-comment">// 构造symbol存储，防止重复</span><br>    <span class="hljs-keyword">const</span> sym = Symbol();<br><br>    context[sym] = <span class="hljs-keyword">this</span>;<br><br>    <span class="hljs-keyword">const</span> res = context[sym](...arguments);<br>    <span class="hljs-keyword">delete</span> context[sym];<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-keyword">Function</span>.<span class="hljs-built_in">apply</span>(obj, [])<br></code></pre></td></tr></table></figure><ul><li><ol><li>调用apply的对象必须是函数。</li></ol></li><li><ol start="2"><li>apply只接受两个参数，第一个参数和call一样是要指向的对象，第二个参数必须是数组或者是类数组，它们都会转换成类数组再传入fn。如果有多个参数都放在数组里，数组传入fn后会映射到fn对应的参数上。</li></ol></li></ul><p>手写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myApply</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context, <span class="hljs-variable language_">arguments</span></span>) &#123; <span class="hljs-comment">// 与call的区别之一</span><br>    <span class="hljs-comment">// 如果context不传，或者为null、undefined，则置为window</span><br>    context = context || <span class="hljs-variable language_">window</span>;<br><br>    <span class="hljs-comment">// 如果context不是对象，则置为对象</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> context !== <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>        context = <span class="hljs-title class_">Object</span>(context);<br>    &#125;<br><br>    <span class="hljs-comment">// 构造symbol存储，防止重复</span><br>    <span class="hljs-keyword">const</span> sym = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;temp fn&#x27;</span>);<br>    context[sym] = <span class="hljs-variable language_">this</span>;<br><br>    <span class="hljs-keyword">const</span> res = context[sym](...(<span class="hljs-variable language_">arguments</span> || [])); <span class="hljs-comment">// 与call的区别之二</span><br>    <span class="hljs-keyword">delete</span> context[sym];<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">Function</span>.<span class="hljs-keyword">bind</span>(fn, arg1, arg2, ...)<br></code></pre></td></tr></table></figure><ul><li>bingd方法的返回值是函数（bind方法会创建一个新的函数，在调用时设置this关键字为提供的值）</li><li>bind不会立即调用，需要稍后调用的时候才会执行</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context, ...args</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>&#125;</span> it is not a function`</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 保留this</span><br>    <span class="hljs-keyword">const</span> self = <span class="hljs-variable language_">this</span>;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">fNop</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">bindFn</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 1.bind返回的函数可能会作为构造函数，这种情况下bind绑定的this值会失效，但传入的参数依然有效。</span><br>        <span class="hljs-comment">// 2.当作为构造函数时，this指向实例，故我们可以通过判断this是否指向bindFn得知当前bind返回的函数是否被用做构造函数</span><br>        <span class="hljs-comment">// 3. 当为构造函数</span><br>        <span class="hljs-keyword">return</span> self.<span class="hljs-title function_">aplly</span>(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> bindFn ? <span class="hljs-variable language_">this</span> : context, args.<span class="hljs-title function_">concat</span>(<span class="hljs-variable language_">arguments</span>));<br>    &#125;<br>    <span class="hljs-comment">// 将函数的原型与调用的原型绑定，以能继承调用方的原型方法</span><br>    <span class="hljs-comment">// 不直接bindFn.prototype = this.prototype;的原因是这样修改bindFn的prototype时也会修改到this这个函数的prototype。通过用一个空函数中转来解决这个问题</span><br>    fNop.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>;<br>    bindFn.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_">fNop</span>();<br><br>    <span class="hljs-keyword">return</span> bindFn;<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-keyword">var</span> foo = &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">1</span>&#125;;<br><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">function</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name, age);<br>&#125;<br><span class="hljs-keyword">var</span> res = bar.<span class="hljs-title function_">bind</span>(foo, <span class="hljs-string">&#x27;jjj&#x27;</span>);<br><span class="hljs-title function_">res</span>(<span class="hljs-number">26</span>); <span class="hljs-comment">// 1  jjj 26</span><br></code></pre></td></tr></table></figure><h1 id="一些基础知识"><a href="#一些基础知识" class="headerlink" title="一些基础知识"></a>一些基础知识</h1><h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><p>arguments是一个对应于传递给函数的参数的<b>类数组对象</b>，arguments对象是所有（非箭头）函数中都可用的局部变量。</p><ul><li>箭头函数没有arguments和this</li><li>arguments转数组：Array.from(ES6)、Array.prototype.slice.call(arguments)、自行遍历</li></ul><h2 id="类数组对象"><a href="#类数组对象" class="headerlink" title="类数组对象"></a>类数组对象</h2><p>类数组对象，即可以通过<b>索引访问元素</b>并且<b>拥有length属性</b>的对象。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> arrLike = &#123;<br>  <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;name&#x27;</span>,<br>  <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;age&#x27;</span>,<br>  <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;job&#x27;</span>,<br>  length: <span class="hljs-number">3</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="剩余参数（ES6）"><a href="#剩余参数（ES6）" class="headerlink" title="剩余参数（ES6）"></a>剩余参数（ES6）</h2><p>剩余参数允许<b>将一个不定量的参数表示为一个数组</b>。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span> <span class="hljs-params">(num1, <span class="hljs-rest_arg">...arguments</span>)</span> &#123;<br>    console.log(arguments)<br>&#125;<br><br>sum(<span class="hljs-number">10</span>) <span class="hljs-comment">// []</span><br>sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>) <span class="hljs-comment">// [ 20 ]</span><br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/dongcanliang/p/7054176.html">https://www.cnblogs.com/dongcanliang/p/7054176.html</a><br><a href="https://www.cnblogs.com/jsunwang/p/13393353.html">https://www.cnblogs.com/jsunwang/p/13393353.html</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变量对象、函数提升与变量提升</title>
    <link href="/2023/04/20/%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E3%80%81%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87%E4%B8%8E%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"/>
    <url>/2023/04/20/%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E3%80%81%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87%E4%B8%8E%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</url>
    
    <content type="html"><![CDATA[<p>变量对象、函数提升与变量提升</p><p>由《执行上下文栈》我们可知JavaScript每执行一段可执行代码时，都会创建对应的执行上下文。</p><p>对于每个执行上下文，都有三个重要属性：</p><ul><li>变量对象</li><li>作用域链</li><li>this</li></ul><p>本篇主要介绍变量对象以及变量对象创建的过程。</p><h1 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h1><p>变量对象是<b>与执行上下文相关的数据作用域</b>，存储了在上下文中定义的变量对象和函数声明。</p><p>因为不同执行上下文的变量对象稍有不同，我们主要讲下 全局上下文和函数上下文 下的变量对象。</p><h1 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h1><blockquote><p>在顶层JavaScript代码中，可以用关键字this引用全局对象。因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。</p></blockquote><p>全局对象我们都不陌生了，我们来进一步介绍下：</p><ol><li><p>可以通过this引用，在客户端JavaScript中，全局对象就是Window对象。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">console.log(this <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> window)<span class="hljs-comment">; // 在顶层JavaScript打印，结果为true，控制台可验证</span><br></code></pre></td></tr></table></figure></li><li><p>全局对象是由Object构造函数实例化的一个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p>预定义一堆函数和属性，比如Date、Math、Number、String等这些内置函数。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">random</span>()); <span class="hljs-comment">// 能正常打印，不会报错，因为预定义了</span><br></code></pre></td></tr></table></figure></li><li><p>作为全局变量的诉诸，全局变量都存储在这里。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.a); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure></li><li><p>客户端JavaScript中，全局对象有window对象指向自身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">a</span>); <span class="hljs-comment">// 1</span><br><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">window</span>.<span class="hljs-property">b</span> = <span class="hljs-number">2</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span>); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure></li></ol><p>通过以上几个点，我们可以很明确的知道：<b>全局上下文的变量对象就是全局对象。</b></p><h1 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h1><p>在函数上下文中，我们用活动对象（Activation Object，AO）来表示变量对象。</p><p>活动对象可以说是处于激活状态的变量对象，只有当进入一个执行上下文中时，这个执行上下文的变量对象才会被激活，成为活动对象。只有被激活的变量对象也就是活动对象上的各种属性才能被访问。</p><p>活动对象是在进入函数上下文时被创建的，它通过函数的arguments属性初始化，arguments属性值是Arguments。</p><h1 id="代码执行过程"><a href="#代码执行过程" class="headerlink" title="代码执行过程"></a>代码执行过程</h1><p>执行上下文的代码会分两个阶段处理：<b>分析和执行</b></p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>当进入执行上下文时，这是很好还没有执行代码，变量对象包括</p><ol><li>函数的所有<b>形参</b>（针对函数上下文）<ul><li>由名称和对应值组成的一个变量对象的属性被创建</li><li>没有实参，属性值为undefined</li></ul></li><li><b>函数</b>声明（也就是<b>函数提升</b>）<ul><li>由名称和对应值（函数对象）组成一个变量对象的属性被创建</li><li>如果变量对象已经存在相同名称的属性，则会覆盖这个属性</li></ul></li><li><b>变量</b>声明（也就是<b>变量提升</b>）<ul><li>由名称和对应值（undefined）组成一个变量对象的属性被创建</li><li>如果变量名称跟已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性</li></ul></li></ol><p>举下面这个例子：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(a)</span> &#123;<br>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">c</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">var</span> d = <span class="hljs-keyword">function</span><span class="hljs-params">()</span> &#123;&#125;;<br>    b = <span class="hljs-number">3</span>;<br>&#125;<br><br>foo(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>进入执行上下文后，该上下文的活动对象为：</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">AO = &#123;</span><br><span class="hljs-attribute">    arguments</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#123;</span><br>        <span class="hljs-attribute">0</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1,</span><br>        <span class="hljs-attribute">length</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1</span><br>    <span class="hljs-attribute">&#125;,</span><br><span class="hljs-attribute">    a</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1,</span><br>    <span class="hljs-attribute">b</span><span class="hljs-punctuation">:</span> <span class="hljs-string">undefined,</span><br>    <span class="hljs-attribute">c</span><span class="hljs-punctuation">:</span> <span class="hljs-string">reference to function c()&#123;&#125;,</span><br>    <span class="hljs-attribute">d</span><span class="hljs-punctuation">:</span> <span class="hljs-string">undefined</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h2><p>在代码执行阶段，会顺序执行代码，根据代码修改变量对象的属性值。</p><p>上面的例子进入代码执行后，活动对象会变为：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dts">AO = <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    arguments:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-number">0</span>: <span class="hljs-number">1</span>,<br><span class="hljs-symbol">        length:</span> <span class="hljs-number">1</span><br>    <span class="hljs-punctuation">&#125;</span>,<br><span class="hljs-symbol">    a:</span> <span class="hljs-number">1</span>,<br><span class="hljs-symbol">    b:</span> <span class="hljs-number">2</span>,<br><span class="hljs-symbol">    c:</span> reference to function c()<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>,<br><span class="hljs-symbol">    d:</span> reference to FunctionExpression <span class="hljs-string">&quot;d&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="其他例子"><a href="#其他例子" class="headerlink" title="其他例子"></a>其他例子</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(foo);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;foo&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> foo = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>这个例子，最终会打印函数，因为<b>变量声明时若已有同名的函数或形参声明过，则不会覆盖。</b>所以foo首先声明为一个函数，foo再作为变量想声明时不会覆盖前面的函数，所以打印出来的是函数。</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>作用域链</title>
    <link href="/2023/04/19/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
    <url>/2023/04/19/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<p>作用域链</p><p>由《执行上下文栈》我们可知JavaScript每执行一段可执行代码时，都会创建对应的执行上下文。</p><p>对于每个执行上下文，都有三个重要属性：</p><ul><li>变量对象</li><li>作用域链</li><li>this</li></ul><p>本篇主要介绍作用域链。</p><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>什么是作用域？作用域是指程序源代码中定义变量的区域。它规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</p><p><b>JavaScript采用词法作用域，也就是静态作用域。</b></p><h1 id="静态作用域与动态作用域"><a href="#静态作用域与动态作用域" class="headerlink" title="静态作用域与动态作用域"></a>静态作用域与动态作用域</h1><p>词法作用域中函数的作用域在<b>函数定义</b>的时候就决定了，而动态作用域是在<b>函数调用</b>的时候才决定的。</p><p>用以下这个例子来说明：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> value = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(value);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> value = <span class="hljs-number">2</span>;<br>    foo();<br>&#125;<br><br>bar();<br><br><span class="hljs-comment">// 输出：？</span><br></code></pre></td></tr></table></figure><p>假设JavaScript采用静态作用域，则执行过程应该如下：<br>执行foo函数 -&gt; 先查找foo函数内部是否有局部变量value -&gt; 没有查找到 -&gt; 因为是静态作用域，在定义时就决定了变量的可访问区域，所以根据书写位置，查找上一层的作用域是否有变量value -&gt; 查找到value为1 -&gt; 打印1。</p><p>假设JavaScript采用动态作用域，则执行过程应该如下：<br>执行foo函数 -&gt; 先查找foo函数内部是否有局部变量 -&gt; 没有查找到 -&gt; 因为是动态作用域，所以从调用函数的作用域，也就是bar函数内部查找 -&gt; 查找到到calue为2 -&gt; 打印2。</p><p>我们可以在控制台尝试一下，可以知道最后打印出来的是1，也就验证了JavaScript采用的是静态作用域。</p><h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><p>在《变量对象》中讲到，当查找变量的时候，会先从当前上下文的变量对象中查找，如果没找到，就会从<b>父级（词法层面的父级）</b>执行上下文的变量对象中查找，一直查找到全局上下文的变量对象，也就是全局变量。</p><p><b>这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</b></p><p>接下来，让我们以一个函数的<b>创建</b>和<b>激活</b>两个时期来讲解作用域链是如何创建和变化的。</p><h2 id="函数创建"><a href="#函数创建" class="headerlink" title="函数创建"></a>函数创建</h2><p>上文 词法作用域和动态作用域 部分有讲到，函数的作用域是在函数定义的时候就决定了。</p><p>这是因为函数内部有一个属性[[scope]]，当函数创建的时候，就会保存父变量对象到其中，我们可以理解[[scope]]就是父变量对象的层级链。</p><blockquote><p>注意：[[scope]]并不代表完整的作用域链！</p></blockquote><p>举个例子，有这样一个函数：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span><span class="hljs-params">()</span> &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数创建时，各自的[[scope]]为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua">foo.<span class="hljs-string">[[scope]]</span> = [<br>    globalContext.VO<br>];<br>bar.<span class="hljs-string">[[scope]]</span> = [<br>    fooContext.AO,<br>    globalContext.VO<br>];<br></code></pre></td></tr></table></figure><h2 id="函数激活"><a href="#函数激活" class="headerlink" title="函数激活"></a>函数激活</h2><p>当函数激活时，进入函数上下文，创建AO和VO后，就会将活动对象添加到作用域的前端。<br>这时候执行上下文的作用域链，假设将它命名为Scope:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">Scope = [AO].CONCACT(<span class="hljs-string">[[Scope]]</span>);<br></code></pre></td></tr></table></figure><p>至此，作用域链创建完毕。</p><h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>以下面例子为例，结合之前讲的变量对象和执行上下文栈，我们来总结一下函数执行上下文中作用域链和变量对象的创建过程。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> scope = “<span class="hljs-keyword">global</span> scope”;<br><span class="hljs-function">function <span class="hljs-title">checkscope</span>()</span> &#123;<br>    <span class="hljs-keyword">var</span> scope2 = <span class="hljs-string">&#x27;local scope&#x27;</span>;<br>    <span class="hljs-keyword">return</span> scope2;<br>&#125;<br>checkscope();<br></code></pre></td></tr></table></figure><p>执行过程如下：</p><ol><li>checkscope函数被创建，保存作用域链到内部属性[[scope]]<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">chekscope.<span class="hljs-string">[[scope]]</span> = [<br>    globalContext.VO<br>];<br></code></pre></td></tr></table></figure></li><li>执行checkscope函数，创建checkscope函数执行上下文，checkscope函数上下文被压入执行上下文栈<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ECStack</span> = [<br>    checkscopeContext,<br>    globalContext<br>]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li>checkscope函数并不立刻执行，开始做准备工作。第一步：复制函数[[scope]]属性创建作用域链<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">checkscopeContext = &#123;<br>    Scope: checkscope.<span class="hljs-string">[[scope]]</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>第二步：用arguments创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dts">checkscopeC<span class="hljs-attr">ontext</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    AO:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">        arguments:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">            length:</span> <span class="hljs-number">0</span><br>        <span class="hljs-punctuation">&#125;</span>,<br><span class="hljs-symbol">        scope2:</span> undefined<br>    <span class="hljs-punctuation">&#125;</span>,<br><span class="hljs-symbol">    Scope:</span> checkscope.[[scope]]<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li>第三步：将活动对象压入checkscope作用域链顶端<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dts">checkscopeC<span class="hljs-attr">ontext</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    AO:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">        arguments:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">            length:</span> <span class="hljs-number">0</span><br>        <span class="hljs-punctuation">&#125;</span>,<br><span class="hljs-symbol">        scope2:</span> undefined<br>    <span class="hljs-punctuation">&#125;</span>,<br><span class="hljs-symbol">    Scope:</span> [AO, [[Scope]]]<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li>准备工作做完，开始执行函数，随着函数的执行，修改AO的属性值<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua">checkscopeContext = &#123;<br>    AO: &#123;<br>        arguments: &#123;<br>            length: <span class="hljs-number">0</span><br>        &#125;,<br>        scope2: <span class="hljs-string">&#x27;local scope&#x27;</span><br>    &#125;,<br>    Scope: [AO, <span class="hljs-string">[[Scope]]</span>]<br>&#125;<br></code></pre></td></tr></table></figure></li><li>查找到scope2的值，返回后函数执行完毕，函数执行上下文从执行上下文栈中弹出。<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">ECStack</span> <span class="hljs-operator">=</span> [<br>    globalContext<br>]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/mqyqingfeng/Blog/issues/6">https://github.com/mqyqingfeng/Blog/issues/6</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>执行上下文栈</title>
    <link href="/2023/04/19/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/"/>
    <url>/2023/04/19/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<p>执行上下文栈</p><p>首先我们都知道JavaScript代码是顺序执行，那么具体是怎么做的呢？我们来了解一下作用域和执行上下文。</p><h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p>我们知道JavaScript是顺序执行的，但是又有变量提升和函数提升的机制，这两点为什么不冲突呢？</p><p>因为JavaScript引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会先进行一个“准备工作”，就包括前面所说的变量提升和函数提升。</p><p>但是一段一段地分析，这个“段”是怎么划分的呢？所以我们就要提到JavaScript的可执行代码了。</p><p>JavaScript的可执行性代码分为三种：<b>全局代码、函数代码、eval代码</b>。</p><p>比如当执行到一个函数时，就是一段可执行代码，就会为之创建对应的执行上下文。</p><p>那么因此执行上下文对应也有三种：<b>全局执行上下文、函数执行上下文、eval执行上下文</b>。</p><blockquote><p>eval函数回计算JavaScript字符串，并把它当脚本代码来执行。由于eval函数很少使用，不做介绍。</p></blockquote><h1 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h1><p>我们知道，实际的工作项目中，函数的数量非常多，每个函数都会创建一个执行上下文，那怎么管理创建的那么多执行上下文呢？</p><p>因此JavaScript引擎创建了<b>执行上下文栈</b>来管理执行上下文。</p><p>我们暂且将执行上下文栈定义为一个数组，来模拟执行上下文栈的行为。假设执行上下文栈是数组ECStack：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var ECStack <span class="hljs-operator">=</span> []<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>当JavaScript开始解析执行代码的时候，最先遇到的肯定是全局代码，所以最开始首先会向执行上下文栈押入一个全局执行上下文，假设用globalContext来表示它，只有当整个应用程序结束的时候，ECStack才会被清空，因此在清空钱，ECStack最底部一直都会是globalContext。</p><p>当执行一个函数的时候，就会创建一个执行上下文，并且推入执行上下文栈，当函数执行完毕时，就会将函数的执行上下文从栈中弹出。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss">function <span class="hljs-built_in">fun3</span>() &#123;<br>    console<span class="hljs-selector-class">.log</span>(&#x27;func3&#x27;);<br>&#125;<br><br>function <span class="hljs-built_in">fun2</span>() &#123;<br>    <span class="hljs-built_in">fun3</span>();<br>&#125;<br><br>function <span class="hljs-built_in">fun1</span>() &#123;<br>    <span class="hljs-built_in">fun2</span>();<br>&#125;<br><br><span class="hljs-built_in">fun1</span>();<br></code></pre></td></tr></table></figure><p>我们用以上这段代码来模拟以下执行上下文栈进出栈的过程：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 伪代码<br><br><span class="hljs-regexp">//</span> 首先推入全局上下文<br>ECStack.push(globalContext);<br><br><span class="hljs-regexp">//</span> ...其他代码<br><br><span class="hljs-regexp">//</span> 执行fun1()<br>ECStack.push(&lt;fun1&gt; functionContext);<br><br><span class="hljs-regexp">//</span> fun1中调用了fun2<br>ECStack.push(&lt;fun2&gt; functionContext);<br><br><span class="hljs-regexp">//</span> fun2中调用了fun3<br>ECStack.push(&lt;fun3&gt; functionContext);<br><br><span class="hljs-regexp">//</span> fun3执行完毕<br>ECStack.pop();<br><br><span class="hljs-regexp">//</span> fun2执行完毕<br>ECStack.pop();<br><br><span class="hljs-regexp">//</span> fun1执行完毕<br>ECStack.pop();<br><br><span class="hljs-regexp">//</span> ...接着执行其他代码<br><br><span class="hljs-regexp">//</span> 整个应用程序结束的时候，最后推出全局上下文<br>ECStack.pop();<br></code></pre></td></tr></table></figure><h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>从以下两个例子，我们可以很容易看到执行上下文栈变化的不一样。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 例子1</span><br><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkscope</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;local scope&quot;</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> scope;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f();<br>&#125;<br>checkscope();<br></code></pre></td></tr></table></figure><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 例子2</span><br><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkscope</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;local scope&quot;</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> scope;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f;<br>&#125;<br>checkscope()();<br></code></pre></td></tr></table></figure><p>我们可以通过模拟的方式看到执行上下文栈变化的不同：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 例子2</span><br>ECStack.<span class="hljs-built_in">push</span>(&lt;checkscope&gt; functionContext);<br>ECStack.<span class="hljs-built_in">push</span>(&lt;f&gt; functionContext);<br>ECStack.<span class="hljs-built_in">pop</span>();<br>ECStack.<span class="hljs-built_in">pop</span>();<br></code></pre></td></tr></table></figure><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 例子2</span><br>ECStack.<span class="hljs-built_in">push</span>(&lt;checkscope&gt; functionContext);<br>ECStack.<span class="hljs-built_in">pop</span>();<br>ECStack.<span class="hljs-built_in">push</span>(&lt;f&gt; functionContext);<br>ECStack.<span class="hljs-built_in">pop</span>();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>继承</title>
    <link href="/2023/04/17/%E7%BB%A7%E6%89%BF/"/>
    <url>/2023/04/17/%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<p>继承</p><h1 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;jjj&#x27;</span>;<br>&#125;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;<br><span class="hljs-title class_">Child</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br><span class="hljs-keyword">var</span> children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Child</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(children.<span class="hljs-title function_">getName</span>()); <span class="hljs-comment">// jjj</span><br></code></pre></td></tr></table></figure><p>通过原型链实现对<b>原型属性和方法以及实例属性</b>的继承。</p><p>问题：</p><ol><li><b>引用类型</b>的属性被所有实例共享，实例对原型上引用类型属性的修改会影响到所有实例。(因为实例属性也是通过原型链继承的)<blockquote><p>所有实例共享原型链上的所有属性。但是如果在一个实例中修改原型链上的属性，就要分情况了：</p></blockquote></li></ol><ul><li>如果修改的是引用类型的，原型和其他的实例都会受影响；</li><li>如果修改的是非引用类型的，实际上是在实例本身创建了一个同名的属性，不会影响原型链上本身的属性<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Parent</span>(<span class="hljs-params"></span>) &#123;<br>    this.name = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Child</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;<br>Child.prototype = <span class="hljs-keyword">new</span> Parent();<br><br><span class="hljs-keyword">var</span> child1 = <span class="hljs-keyword">new</span> Child();<br>child1.name.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(child1.name); <span class="hljs-comment">// [1, 2, 3]</span><br><br><span class="hljs-keyword">var</span> child2 = <span class="hljs-keyword">new</span> Child();<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(child2.name); <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure></li></ul><ol start="2"><li>再创建child实例时，不能向Parent传参</li></ol><h1 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h1><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">superType</span>(<span class="hljs-params">name</span>) &#123;<br>    this.name = name;<br>    this.colors = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>];<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">subType</span>(<span class="hljs-params">name, age</span>) &#123;<br>    superType.call(this, name);<br>    this.age = age;<br>&#125;<br><br><span class="hljs-keyword">var</span> instance1 = <span class="hljs-keyword">new</span> subType(<span class="hljs-string">&#x27;jjj&#x27;</span>, <span class="hljs-number">26</span>);<br>instance1.colors.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;yellow&#x27;</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(instance1.name);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(instance1.colors);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(instance1.age);<br><br><span class="hljs-keyword">var</span> instance2 = <span class="hljs-keyword">new</span> subType(<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-number">3</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(instance2.name);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(instance2.colors);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(instance2.age);<br></code></pre></td></tr></table></figure><p>通过借用构造函数解决了实例属性的继承，这样引用类型的属性在新创建的实例对象中不会被所有实例共享。</p><p>问题：</p><ol><li>函数方法不能共享，方法都在构造函数中定义，每次创建实例都会创建一遍方法。</li><li>需要调用两次构造函数，且超类型构造函数上的属性被重复创建在子类型的实例和原型上。第一次<code>subType.prototype = new superType()</code>时会在subType.prototype这个原型上创建name和colors属性，第二次调用构造函数执行<code>superType.call(this, name)</code>会在subType新创建的实例上创建name和colors属性，最后实例上的属性覆盖原型上的属性，这个过程是有冗余的。</li></ol><h1 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">superType</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>]; <br>&#125;<br>superType.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">subType</span>(<span class="hljs-params">name, age</span>) &#123;<br>    superType.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br>subType.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> superType();<br>subType.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> = subType;<br>subType.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayAge</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> instance1 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">subType</span>(<span class="hljs-string">&#x27;jjj&#x27;</span>, <span class="hljs-number">26</span>);<br>instance1.<span class="hljs-property">colors</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;yellow&#x27;</span>);<br>instance1.<span class="hljs-title function_">sayName</span>();<br>instance1.<span class="hljs-title function_">sayAge</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance1.<span class="hljs-property">colors</span>);<br><br><span class="hljs-keyword">var</span> instance2 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">subType</span>(<span class="hljs-string">&#x27;Tom&#x27;</span>, <span class="hljs-number">3</span>);<br>instance2.<span class="hljs-title function_">sayName</span>();<br>instance2.<span class="hljs-title function_">sayAge</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance2.<span class="hljs-property">colors</span>);<br></code></pre></td></tr></table></figure><p>使用<b>原型链&gt;</b>实现对<b>原型属性和方法</b>的继承，使用<b>借用构造函数</b>实现对<b>实例属性</b>的继承。</p><p>问题：</p><ol><li>仍然会调用两次超类型构造函数。借用构造函数继承 中的第2个问题还是会存在。</li></ol><h1 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h1><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> create<span class="hljs-constructor">Object(<span class="hljs-params">o</span>)</span> &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-constructor">F()</span> &#123;&#125;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">F</span>.</span></span>prototype = o;<br>    return <span class="hljs-keyword">new</span> <span class="hljs-constructor">F()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>即ES6中Object.create()的模拟实现，将<b>传入的对象作为创建的对象的原型</b>。</p><p>问题：</p><ol><li>和原型链继承一样，引用类型的属性会被所有实例所共享。</li></ol><h1 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">subType</span>(<span class="hljs-params">o</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-keyword">clone</span> = <span class="hljs-title function_ invoke__">createObject</span>(o);<br>    <span class="hljs-keyword">clone</span>.<span class="hljs-title function_ invoke__">sayAge</span>() = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        console.<span class="hljs-title function_ invoke__">log</span>(this.age);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">clone</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>寄生式继承创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。</p><h1 id="组合寄生式继承"><a href="#组合寄生式继承" class="headerlink" title="组合寄生式继承"></a>组合寄生式继承</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">superType</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>  = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>];<br>&#125;<br>superType.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">subType</span>(<span class="hljs-params">name, age</span>) &#123;<br>    superType.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createObject</span>(<span class="hljs-params">o</span>) &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123;&#125;<br>    F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = o;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">inheritPrototype</span>(<span class="hljs-params">subType, superType</span>) &#123;<br>    <span class="hljs-keyword">let</span> clone = <span class="hljs-title function_">createObject</span>(superType.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>    clone.<span class="hljs-property">constructor</span> = subType;<br>    subType.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = clone;<br>&#125;<br><span class="hljs-title function_">inheritPrototype</span>(subType, superType);<br><br><span class="hljs-keyword">var</span> instance1 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">subType</span>(<span class="hljs-string">&#x27;jjj&#x27;</span>, <span class="hljs-number">26</span>);<br>instance1.<span class="hljs-property">colors</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;yellow&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance1.<span class="hljs-property">name</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance1.<span class="hljs-property">age</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance1.<span class="hljs-property">colors</span>);<br><br><span class="hljs-keyword">var</span> instance2 = <span class="hljs-keyword">new</span> <span class="hljs-title function_">subType</span>(<span class="hljs-string">&#x27;john&#x27;</span>, <span class="hljs-number">6</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance2.<span class="hljs-property">name</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance2.<span class="hljs-property">age</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance2.<span class="hljs-property">colors</span>);<br></code></pre></td></tr></table></figure><p>寄生组合继承高效率体现在它只调用了一次superType构造函数，并且避免了在subType.prototype上再创建不必要的、多余的属性。与此同时，原型链保持不变，也能够正常的使用instanceof和isPrototypeOf。这是最理想的继承方式。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p><a href="https://github.com/mqyqingfeng/Blog/issues/16">https://github.com/mqyqingfeng/Blog/issues/16</a></p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原型链</title>
    <link href="/2023/04/15/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/2023/04/15/%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<p>原型链</p><p>以以下一个简单的例子入手：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br><br>&#125;<br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person();<br></code></pre></td></tr></table></figure><h1 id="构造函数与实例对象"><a href="#构造函数与实例对象" class="headerlink" title="构造函数与实例对象"></a>构造函数与实例对象</h1><p>在上述例子中，<code>Person</code>就是一个构造函数，<code>person</code>就是使用new实例化出来的一个实例对象。</p><p><img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE/1.png" alt="1"></p><h1 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h1><p>每个函数都有一个prototype属性，我们经常看到如下的例子：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;<br>Person.prototyoe.name = <span class="hljs-string">&#x27;TOM&#x27;</span>;<br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(person1.name); <span class="hljs-comment">// TOM</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(person2.name); <span class="hljs-comment">// TOM</span><br></code></pre></td></tr></table></figure><p>注意：<b>prototype是函数才会有的属性。</b>那这个prototype到底指向了什么呢？</p><p>其实，<b>函数的prototype属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型。</b>即这个例子中，Person的prototype也就是person1和person2的原型。</p><p>那什么是原型呢？可以这样理解：<b>每一个JavaScript对象（null除外）在创建的时候都会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型继承属性。</b></p><p>可以用以下这张图来表示构造函数和实例原型之间的关系：</p><p><img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE/2.png" alt="2"></p><p>如上图，Person是构造函数，我们用Person.prototype表示实例原型。那我们该怎么表示实例与实例原型，也就是person与Person.prototype间的关系呢？这时候我们需要介绍第二个属性：_proto_。</p><h1 id="proto"><a href="#proto" class="headerlink" title="proto"></a><em>proto</em></h1><p><b>每一个JavaScript对象（除了null）都具有一个对象，叫_proto_，这个属性会指向该对象的原型，也就是实例化该对象出来的构造函数的prototype。</b><br>我们可以通过以下例子证明这一点：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;<br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(person._proto_ === Person.prototype); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>于是我们可以更新关系图如下：</p><p><img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE/3.png" alt="3"></p><p>既然实例对象和构造函数都可以指向实例原型，那么实例原型可以指向实例对象和构造函数吗？</p><p>从原型到实例对象的指向是没有的，因为一个构造函数可以生成多个实例。但是原型可以指向构造函数，这里需要介绍第三个属性：constructor。</p><h1 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h1><p>每一个原型都有一个constructor属性指向关联的的构造函数。我们可以通过以下例子证明这一点：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(Person.prototype.constructor === Person); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>于是我们可以更新关系图如下：</p><p><img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE/4.png" alt="4"></p><p>综上，我们了解了构造函数、实例原型、实例三者之间的关系，接下来了解以下实例和原型之间的关系。</p><h1 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h1><p><b>当读取实例的属性时，如果找不到，就会查找与实例对象关联的原型中的属性，如果还是找不到，就会向上去找原型的原型，一直找到最顶层为止。</b>我们可以看以下的例子：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;<br>Person.prototype.name = <span class="hljs-string">&#x27;Tom&#x27;</span>;<br><br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person();<br><br>person.name = <span class="hljs-string">&#x27;Jack&#x27;</span>;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(person.name); <span class="hljs-comment">// Jack</span><br><br>delete person.name;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(person.name); <span class="hljs-comment">// Tom</span><br></code></pre></td></tr></table></figure><p>在以上示例中，我们给实例对象person添加了name属性，当我们打印person.name时，自然打印的是person的name属性值’Jack’。</p><p>但是当我们删除person的name属性后，再读取person.name，从person对象中找不到name属性就会从person的原型也就是person._proto_，也就是Person.prototype中查找，于是打印出来的是Person.prototype的name属性值’Tom’。</p><p>同样的，当我们获取preson.constructor时，其实person中并没有constructor属性，当查找不到时，就会从person的原型也就是Person.prototype中读取，即：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">person.constrcutor <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> Person.prototype.constructor <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> Person<br></code></pre></td></tr></table></figure><p>那如果person的原型也就是person._proto_中没找到呢？原型的原型又是什么？</p><h1 id="原型的原型"><a href="#原型的原型" class="headerlink" title="原型的原型"></a>原型的原型</h1><p>前面我们说到函数的prototype指向一个对象，也就是原型也是一个对象。既然是对象，我们就可以用原始的Object构造函数创建它：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> Object();<br>obj.name = <span class="hljs-string">&#x27;TOM&#x27;</span>;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(obj.name); <span class="hljs-comment">// TOM</span><br></code></pre></td></tr></table></figure><p>其实原型对象就是通过Object函数创建出来的，结合之前说的实例的_proto_指向构造函数的prototype，所以原型的_proto_就指向Object的prototype。</p><p>我们可以更新关系图如下：</p><p><img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE/5.png" alt="5"></p><h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>原型的原型是Object.prototype，那么Object.prototype的原型是什么呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_proto_</span>); <span class="hljs-comment">// null</span><br></code></pre></td></tr></table></figure><p>由上可见，Object.prototype的原型是null。</p><blockquote><p>null表示“没有对象”，即该处不该有值。 – 阮一峰《undefined与null的区别》</p></blockquote><p>所以我们可以理解为：Object.prototype._proto_的值为null，也就是说Object.prototype没有原型。</p><p>所以查找属性的时候，查到Object.prototype就可以停止查找了。我们可以更新关系图如下：</p><p><img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE/6.png" alt="6"></p><p>我们常说的<b>原型链就是由相互关联的原型组成的链状结构</b>，也就是图中蓝色的这条线。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>参考：<a href="https://github.com/mqyqingfeng/Blog/issues/2">https://github.com/mqyqingfeng/Blog/issues/2</a></p><h1 id="相关扩展点"><a href="#相关扩展点" class="headerlink" title="相关扩展点"></a>相关扩展点</h1><p>new<br>继承</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目经验</title>
    <link href="/2023/02/15/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C/"/>
    <url>/2023/02/15/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a>项目经验</h1><h2 id="一、npm引入双包做实验"><a href="#一、npm引入双包做实验" class="headerlink" title="一、npm引入双包做实验"></a>一、npm引入双包做实验</h2><p>可引入一个包的不同版本做AB实验，实验内使用新包，实验外使用旧包</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-string">&quot;package&quot;</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>,<br><span class="hljs-string">&quot;package-new&quot;</span>: <span class="hljs-string">&quot;npm:package@1.0.1&quot;</span>,<br></code></pre></td></tr></table></figure><h2 id="二、动态引入外部包：import和import"><a href="#二、动态引入外部包：import和import" class="headerlink" title="二、动态引入外部包：import和import()"></a>二、动态引入外部包：import和import()</h2><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p><code>import</code>语句会被js引擎静态分析，先于模块内的其他模块执行。所以，下面这种代码会报错</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">if</span> (x === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">import</span> otherMoudle <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./otherMoudle&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>引擎处理<code>import</code>语句是在编译时，而if语句这类是运行时处理，所以<code>import</code>语句放在if代码块内会报语法错误。也就是说<code>import</code>和<code>export</code>命令只能在模块的顶层，而不能在代码块之中。</p><p>这样设计有助于提高编译效率，但也导致无法在运行时加载模块，即不能根据业务条件加载，可能会导致包体积过大。因此引入import()函数，支持动态加载。</p><h3 id="import-1"><a href="#import-1" class="headerlink" title="import()"></a>import()</h3><p><code>import()</code>类似node中的require，是在运行时加载模块，即可以实现动态加载。区别主要在于<code>import()</code>是<code>异步加载</code>，<code>require</code>是<code>同步加载</code>;</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;sdkPackage&#x27;</span>).then(sdk =&gt; &#123;<br>    <span class="hljs-keyword">const</span> sdkInstanse = <span class="hljs-keyword">new</span> sdk.<span class="hljs-keyword">default</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><p>ES6 import()返回一个Promise对象，以上是一个例子。<code>import()</code>函数可以用在任何地方，不仅仅是模块，也可以是非模块的脚本。下面是<code>import()</code>的一些适用场合。</p><h4 id="（1）按需加载"><a href="#（1）按需加载" class="headerlink" title="（1）按需加载"></a>（1）按需加载</h4><p>import()可以在需要的时候在加载某个模块</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart">button.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, event =&gt; &#123;<br>    <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./dialogBox.js&#x27;</span>).then(dialogBox =&gt; &#123;<br>        dialogBox.open();<br>    &#125;).<span class="hljs-keyword">catch</span>(error =&gt; &#123;<br>        <span class="hljs-comment">/* Error handling */</span><br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>比如以上代码，<code>import()</code>方法放在click事件的监听函数中，只有用户点击了按钮才会加载这个模块。</p><h4 id="（2）条件加载"><a href="#（2）条件加载" class="headerlink" title="（2）条件加载"></a>（2）条件加载</h4><p><code>import()</code>可以放在if等代码块中，根据不同的条件加载不同的模块。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">if</span> (condition) &#123;<br>    <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;moduleA&#x27;</span>).then(<span class="hljs-params">...</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;moduleB&#x27;</span>).then(<span class="hljs-params">...</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，根据是否满足condition，条件加载模块A或者模块B。</p><h4 id="（3）动态的模块路径"><a href="#（3）动态的模块路径" class="headerlink" title="（3）动态的模块路径"></a>（3）动态的模块路径</h4><p><code>import()</code>加载的内容可以是动态生成的路径。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">import</span>(fn())<span class="hljs-selector-class">.then</span>(...);<br></code></pre></td></tr></table></figure><p>上面代码中，import()的内容是一个函数，可以根据函数fn的返回结果，加载不同的模块。</p>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>踩坑记录</title>
    <link href="/2022/11/17/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/11/17/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>常用工具</p><h1 id="css动画"><a href="#css动画" class="headerlink" title="css动画"></a>css动画</h1><p>卡顿：尽量避免使用margin、padding、left、right等来transform，更推荐使用translate、scale</p><h1 id="二维码解析"><a href="#二维码解析" class="headerlink" title="二维码解析"></a>二维码解析</h1><p>个别解析失败问题：todo</p>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css经验</title>
    <link href="/2022/11/04/css%E7%BB%8F%E9%AA%8C/"/>
    <url>/2022/11/04/css%E7%BB%8F%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="css经验"><a href="#css经验" class="headerlink" title="css经验"></a>css经验</h1><h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h2><p>css渐变属性：linear-gradient</p><h3 id="渐变抗锯齿"><a href="#渐变抗锯齿" class="headerlink" title="渐变抗锯齿"></a>渐变抗锯齿</h3><p>锯齿现象：锯齿现象在DPR为1（如ios）的屏幕下特别明显，在dpr&gt;1的高清屏上则相较不明显。<br>锯齿产生原因：网页呈现是基于像素单位的，在一种颜色直接过渡到另外一种颜色时，容易导致可视质量下降。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">37deg</span>), <span class="hljs-number">#000</span> <span class="hljs-number">50%</span>, <span class="hljs-number">#f00</span> <span class="hljs-number">50%</span>, <span class="hljs-number">#f00</span>);<br></code></pre></td></tr></table></figure><p>比如以上代码在50%的地方从#000直接过渡到#f00，仔细看即可看到过渡处的锯齿。<br><img src="/images/css%E7%BB%8F%E9%AA%8C/1.png" alt="1"></p><h3 id="简单的解决方法"><a href="#简单的解决方法" class="headerlink" title="简单的解决方法"></a>简单的解决方法</h3><p>最简单的就是<b>不要直接过渡</b>。将上述代码从50%-50%的直接过渡，改成预留了1%的渐变过渡空间</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">background</span>: linear-gradient(<span class="hljs-number">37</span>deg), #<span class="hljs-number">000</span> <span class="hljs-number">49</span>.<span class="hljs-number">5</span>%, #f00 <span class="hljs-number">49</span>.<span class="hljs-number">5</span>%, #f00);<br></code></pre></td></tr></table></figure><p>即可有效处理过渡处的锯齿问题。改造后效果如下：<br><img src="/images/css%E7%BB%8F%E9%AA%8C/2.png" alt="2"></p><h2 id="css实现文字滚动"><a href="#css实现文字滚动" class="headerlink" title="css实现文字滚动"></a>css实现文字滚动</h2><p>css属性： animation、@keyframes、transform</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">set<span class="hljs-constructor">Animation()</span> &#123;<br>    this.<span class="hljs-constructor">$nextTick(()</span> =&gt; &#123;<br>        const textDom = this.$refs.text;<br>        const canScroll = textDom?.clientWidth &lt; textDom?.scrollWidth;<br>        <span class="hljs-keyword">if</span> (canScroll) &#123;<br>            const styleEl = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">style</span>&#x27;)</span>;<br>            styleEl.id = &#x27;textKeyframe&#x27;;<br>            document.head.append<span class="hljs-constructor">Child(<span class="hljs-params">styleEl</span>)</span>;<br>            const textKeyframe = `<br>                @keyframes wordsLoop &#123;<br>                    <span class="hljs-number">0</span>% &#123;<br>                        transform: translate<span class="hljs-constructor">X(0px)</span><br>                    &#125;<br>                    <span class="hljs-number">10</span>% &#123;<br>                        transform: translate<span class="hljs-constructor">X(0px)</span>;<br>                    &#125;<br>                    <span class="hljs-number">90</span>% &#123;<br>                        transform: translate<span class="hljs-constructor">X($&#123;<span class="hljs-params">textDom</span>?.<span class="hljs-params">clientWidth</span> - <span class="hljs-params">textDom</span>?.<span class="hljs-params">scrollWidth</span>&#125;<span class="hljs-params">px</span>)</span><br>                    &#125;<br>                    <span class="hljs-number">100</span>% &#123;<br>                        transform: translate<span class="hljs-constructor">X($&#123;<span class="hljs-params">textDom</span>?.<span class="hljs-params">clientWidth</span> - <span class="hljs-params">textDom</span>?.<span class="hljs-params">scrollWidth</span>&#125;<span class="hljs-params">px</span>)</span><br>                    &#125;<br>                &#125;<br>            `;<br>            styleEl.sheet.insert<span class="hljs-constructor">Rule(<span class="hljs-params">textKeyframe</span>, 0)</span>;<br>            this.appTextStyle = &#123;<br>                animation: &#x27;wordsLoop <span class="hljs-number">3</span>s linear alternate infinite&#x27;,<br>                &#x27;-webkit-animation&#x27;: &#x27;wordsLoop <span class="hljs-number">3</span>s linear alternate infinite&#x27;<br>            &#125;;<br>        &#125;<br>    &#125;);<br>&#125;,<br></code></pre></td></tr></table></figure><p>滚动的核心动画为@keyframes部分，是否要用动态插入的方式具体要看滚动的规则是怎样的。如果需要根据文本长度动态计算，则可能需要使用动态插入的方式。</p><h3 id="动态插入个别机型不兼容问题"><a href="#动态插入个别机型不兼容问题" class="headerlink" title="动态插入个别机型不兼容问题"></a>动态插入个别机型不兼容问题</h3><p>如果动态插入的动画在个别机型上不动，需要格外注意该<b>动画样式被使用时是不是已经存在</b>。<br>比如上述代码，是先生成了wordsLoop这个keyframes并插入到样式表之后，再通过appTextStyle使用了wordsLoop。使用wordsLoop时wordsLoop是已经存在样式表中的。<br>如果将appTextStyle中的animation部分直接写在css文件中，那么代码初始运行时，wordsLoop还未生成，样式表中还没有该keyframes。即便后面生成插入了，但可能在有的机型上会不兼容不能展示动画。</p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图片引入与iconfont使用</title>
    <link href="/2022/10/12/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/10/12/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="图片引入与iconfont使用"><a href="#图片引入与iconfont使用" class="headerlink" title="图片引入与iconfont使用"></a>图片引入与iconfont使用</h1><h2 id="图片引入"><a href="#图片引入" class="headerlink" title="图片引入"></a>图片引入</h2><p>日常项目开发中，通常ue图中用到的图片ue会给我们切图，我们需要把图使用到代码中，通常使用的引入图片方式有：</p><ol><li>把图片放到代码库的静态资源中。<ul><li>优点：打包进产出，加载后运行时显示快</li><li>缺点：增大打包体积，影响包加载速度</li></ul></li><li>图片上传cdn，生成cdn链接使用url引入<ul><li>优点：可以替换cdn资源来更换图片内容，可以根据拦截器进行权限控制，可以缓存，不影响包体积情况下加载速度也很不错，是最常用的方式</li><li>缺点：需要考虑一些特殊场景，比如svg图片通过url引入使用image标签时，在ios上会很模糊</li></ul></li><li>图标类通过iconfont转base64使用<ul><li>优点：减少图片的http请求</li><li>缺点：base64相当于把字符串直接写在代码文件中，也会增加代码打包体积，一般只在加载小图标时使用</li></ul></li></ol><h2 id="iconfont使用"><a href="#iconfont使用" class="headerlink" title="iconfont使用"></a>iconfont使用</h2><h3 id="1-将要使用的图片上传至iconfont"><a href="#1-将要使用的图片上传至iconfont" class="headerlink" title="1.将要使用的图片上传至iconfont"></a>1.将要使用的图片上传至iconfont</h3><p><img src="/images/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/1.png" alt="1"><br>上传时可能需要几分钟审核，等待一段时间即可</p><h3 id="2-下载图标代码"><a href="#2-下载图标代码" class="headerlink" title="2.下载图标代码"></a>2.下载图标代码</h3><p>审核通过成功上传后，将图标添加进购物车，然后进购物车下载代码<br><img src="/images/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/2.png" alt="2"></p><p><img src="/images/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/3.png" alt="3"></p><h3 id="3-获取iconfont代码文件"><a href="#3-获取iconfont代码文件" class="headerlink" title="3.获取iconfont代码文件"></a>3.获取iconfont代码文件</h3><p>下载成功后，得到一个压缩文件，解压如下<br><img src="/images/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/4.png" alt="4"></p><h3 id="4-将下载的tff文件转换为base64格式"><a href="#4-将下载的tff文件转换为base64格式" class="headerlink" title="4.将下载的tff文件转换为base64格式"></a>4.将下载的tff文件转换为base64格式</h3><p>推荐使用网站：<a href="https://transfonter.org/">https://transfonter.org</a></p><p>按下图配置选项，打开 Base64 encode 选项：<br><img src="/images/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/5.png" alt="5"></p><p>配置完后，添加tff文件，开始转换<br><img src="/images/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/6.png" alt="6"></p><p>转换成功后，点击下载<br><img src="/images/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/7.png" alt="7"></p><p>下载得到压缩文件，解压后会有一个stylesheet.css的css文件<br><img src="/images/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/8.png" alt="8"></p><p>该css文件的字体地址就是base64了<br><img src="/images/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/9.png" alt="9"></p><h3 id="5-在项目中使用"><a href="#5-在项目中使用" class="headerlink" title="5.在项目中使用"></a>5.在项目中使用</h3><p>将上一步得到的css文件代码中的@font-face部分复制至代码中<br>以及第3步iconfont上下载得到的iconfont.css文件中的样式部分复制至代码中<br>最后项目里的css文件如下：<br><img src="/images/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/10.png" alt="10"></p><p>使用的地方：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;iconfont icon-back&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Reference-Document"><a href="#Reference-Document" class="headerlink" title="Reference Document"></a>Reference Document</h2><p><a href="https://www.tytrock.com/topics/327">阿里巴巴 iconfont 字体转 base64 并引入使用</a></p>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack入门</title>
    <link href="/2022/10/11/webpack%E5%85%A5%E9%97%A8/"/>
    <url>/2022/10/11/webpack%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>1.生成package.json文件</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> init<br></code></pre></td></tr></table></figure><p>2.安装webpack</p>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2022/10/11/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2022/10/11/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<p>二分查找</p><h1 id="基本二分查找"><a href="#基本二分查找" class="headerlink" title="基本二分查找"></a>基本二分查找</h1><h1 id="二分查找要点"><a href="#二分查找要点" class="headerlink" title="二分查找要点"></a>二分查找要点</h1><h2 id="如何确定循环结束条件"><a href="#如何确定循环结束条件" class="headerlink" title="如何确定循环结束条件"></a>如何确定循环结束条件</h2><h2 id="区间如何收缩"><a href="#区间如何收缩" class="headerlink" title="区间如何收缩"></a>区间如何收缩</h2><h2 id="如何确定返回值"><a href="#如何确定返回值" class="headerlink" title="如何确定返回值"></a>如何确定返回值</h2><h2 id="Reference-Document"><a href="#Reference-Document" class="headerlink" title="Reference Document"></a>Reference Document</h2><p><a href="https://www.cnblogs.com/labuladong/p/12320448.html">https://www.cnblogs.com/labuladong/p/12320448.html</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用工具</title>
    <link href="/2022/10/08/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    <url>/2022/10/08/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<p>常用工具</p><h1 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h1><p>npm包查询：<a href="https://bundlephobia.com/">https://bundlephobia.com/</a><br>npm包比较：<a href="https://npmtrends.com/">https://npmtrends.com/</a></p><h1 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h1>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用命令</title>
    <link href="/2022/10/08/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/10/08/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>常用命令</p><h1 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm cache clean -f <span class="hljs-regexp">//</span> 清除npm缓存<br></code></pre></td></tr></table></figure><h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用js移位运算符取整</title>
    <link href="/2022/09/28/%E4%BD%BF%E7%94%A8js%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%96%E6%95%B4/"/>
    <url>/2022/09/28/%E4%BD%BF%E7%94%A8js%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%96%E6%95%B4/</url>
    
    <content type="html"><![CDATA[<p>使用js移位运算符取整</p><h1 id="运算符介绍"><a href="#运算符介绍" class="headerlink" title="运算符介绍"></a>运算符介绍</h1><h2 id="有符号右移"><a href="#有符号右移" class="headerlink" title="有符号右移"></a>有符号右移</h2><p><code>&gt;&gt;</code>该操作符会将指定操作数的二进制位向右移动指定的位数。<b>向右被移出的位被丢弃，拷贝最左侧的位以填充左侧。</b>由于新的最左侧的位总是和以前相同，符号位没有被改变。</p><h2 id="无符号右移"><a href="#无符号右移" class="headerlink" title="无符号右移"></a>无符号右移</h2><p><code>&gt;&gt;&gt;</code>该操作符会将第1个操作数向右移动指定的位数。<b>向右被移出的位被丢弃，左侧用0填充。</b>因为符号位变成了0，所以结果总是非负的.</p><h1 id="妙用"><a href="#妙用" class="headerlink" title="妙用"></a>妙用</h1><h2 id="用于取整"><a href="#用于取整" class="headerlink" title="用于取整"></a>用于取整</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">console</span>.log(<span class="hljs-number">3</span>.<span class="hljs-number">14</span> &gt;&gt; <span class="hljs-number">0</span>)  // <span class="hljs-number">3</span><br><span class="hljs-attribute">console</span>.log(<span class="hljs-number">3</span>.<span class="hljs-number">14</span> &gt;&gt;&gt; <span class="hljs-number">0</span>)  // <span class="hljs-number">3</span> (不可对负数取整)<br></code></pre></td></tr></table></figure><h2 id="用于获取除2之后的整数"><a href="#用于获取除2之后的整数" class="headerlink" title="用于获取除2之后的整数"></a>用于获取除2之后的整数</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">console</span>.log(<span class="hljs-number">5</span> &gt;&gt; <span class="hljs-number">1</span>)  // <span class="hljs-number">2</span><br><span class="hljs-attribute">console</span>.log(<span class="hljs-number">4</span> &gt;&gt; <span class="hljs-number">1</span>)  // <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2022/07/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/07/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>设计模式的分类及应用</p><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h1 id="订阅发布模式"><a href="#订阅发布模式" class="headerlink" title="订阅发布模式"></a>订阅发布模式</h1>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/07/22/hello-world/"/>
    <url>/2022/07/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>This website is designed by hexo &amp; fluid, please refer to the following documents for how to use it.</p><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info:<br><a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a><br><a href="https://blog.csdn.net/yaorongke/article/details/119089190">Reference Document</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
