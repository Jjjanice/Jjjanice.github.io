<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>原型链</title>
    <link href="/2023/04/15/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/2023/04/15/%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<p>原型链</p><p>以以下一个简单的例子入手：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br><br>&#125;<br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person();<br></code></pre></td></tr></table></figure><h1 id="构造函数与实例对象"><a href="#构造函数与实例对象" class="headerlink" title="构造函数与实例对象"></a>构造函数与实例对象</h1><p>在上述例子中，<code>Person</code>就是一个构造函数，<code>person</code>就是使用new实例化出来的一个实例对象。</p><p><img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE/1.png" alt="1"></p><h1 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h1><p>每个函数都有一个prototype属性，我们经常看到如下的例子：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;<br>Person.prototyoe.name = <span class="hljs-string">&#x27;TOM&#x27;</span>;<br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(person1.name); <span class="hljs-comment">// TOM</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(person2.name); <span class="hljs-comment">// TOM</span><br></code></pre></td></tr></table></figure><p>注意：<b>prototype是函数才会有的属性。</b>那这个prototype到底指向了什么呢？</p><p>其实，<b>函数的prototype属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型。</b>即这个例子中，Person的prototype也就是person1和person2的原型。</p><p>那什么是原型呢？可以这样理解：<b>每一个JavaScript对象（null除外）在创建的时候都会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型继承属性。</b></p><p>可以用以下这张图来表示构造函数和实例原型之间的关系：</p><p><img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE/2.png" alt="2"></p><p>如上图，Person是构造函数，我们用Person.prototype表示实例原型。那我们该怎么表示实例与实例原型，也就是person与Person.prototype间的关系呢？这时候我们需要介绍第二个属性：_proto_。</p><h1 id="proto"><a href="#proto" class="headerlink" title="proto"></a><em>proto</em></h1><p><b>每一个JavaScript对象（除了null）都具有一个对象，叫_proto_，这个属性会指向该对象的原型，也就是实例化该对象出来的构造函数的prototype。</b><br>我们可以通过以下例子证明这一点：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;<br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(person._proto_ === Person.prototype); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>于是我们可以更新关系图如下：</p><p><img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE/3.png" alt="3"></p><p>既然实例对象和构造函数都可以指向实例原型，那么实例原型可以指向实例对象和构造函数吗？</p><p>从原型到实例对象的指向是没有的，因为一个构造函数可以生成多个实例。但是原型可以指向构造函数，这里需要介绍第三个属性：constructor。</p><h1 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h1><p>每一个原型都有一个constructor属性指向关联的的构造函数。我们可以通过以下例子证明这一点：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(Person.prototype.constructor === Person); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>于是我们可以更新关系图如下：</p><p><img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE/4.png" alt="4"></p><p>综上，我们了解了构造函数、实例原型、实例三者之间的关系，接下来了解以下实例和原型之间的关系。</p><h1 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h1><p><b>当读取实例的属性时，如果找不到，就会查找与实例对象关联的原型中的属性，如果还是找不到，就会向上去找原型的原型，一直找到最顶层为止。</b>我们可以看以下的例子：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;<br>Person.prototype.name = <span class="hljs-string">&#x27;Tom&#x27;</span>;<br><br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person();<br><br>person.name = <span class="hljs-string">&#x27;Jack&#x27;</span>;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(person.name); <span class="hljs-comment">// Jack</span><br><br>delete person.name;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(person.name); <span class="hljs-comment">// Tom</span><br></code></pre></td></tr></table></figure><p>在以上示例中，我们给实例对象person添加了name属性，当我们打印person.name时，自然打印的是person的name属性值’Jack’。</p><p>但是当我们删除person的name属性后，再读取person.name，从person对象中找不到name属性就会从person的原型也就是person._proto_，也就是Person.prototype中查找，于是打印出来的是Person.prototype的name属性值’Tom’。</p><p>同样的，当我们获取preson.constructor时，其实person中并没有constructor属性，当查找不到时，就会从person的原型也就是Person.prototype中读取，即：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">person.constrcutor <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> Person.prototype.constructor <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> Person<br></code></pre></td></tr></table></figure><p>那如果person的原型也就是person._proto_中没找到呢？原型的原型又是什么？</p><h1 id="原型的原型"><a href="#原型的原型" class="headerlink" title="原型的原型"></a>原型的原型</h1><p>前面我们说到函数的prototype指向一个对象，也就是原型也是一个对象。既然是对象，我们就可以用原始的Object构造函数创建它：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> Object();<br>obj.name = <span class="hljs-string">&#x27;TOM&#x27;</span>;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(obj.name); <span class="hljs-comment">// TOM</span><br></code></pre></td></tr></table></figure><p>其实原型对象就是通过Object函数创建出来的，结合之前说的实例的_proto_指向构造函数的prototype，所以原型的_proto_就指向Object的prototype。</p><p>我们可以更新关系图如下：</p><p><img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE/5.png" alt="5"></p><h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>原型的原型是Object.prototype，那么Object.prototype的原型是什么呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_proto_</span>); <span class="hljs-comment">// null</span><br></code></pre></td></tr></table></figure><p>由上可见，Object.prototype的原型是null。</p><blockquote><p>null表示“没有对象”，即该处不该有值。 – 阮一峰《undefined与null的区别》</p></blockquote><p>所以我们可以理解为：Object.prototype._proto_的值为null，也就是说Object.prototype没有原型。</p><p>所以查找属性的时候，查到Object.prototype就可以停止查找了。我们可以更新关系图如下：</p><p><img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE/6.png" alt="6"></p><p>我们常说的<b>原型链就是由相互关联的原型组成的链状结构</b>，也就是图中蓝色的这条线。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>参考：<a href="https://github.com/mqyqingfeng/Blog/issues/2">https://github.com/mqyqingfeng/Blog/issues/2</a></p><h1 id="相关扩展点"><a href="#相关扩展点" class="headerlink" title="相关扩展点"></a>相关扩展点</h1><p>new<br>继承</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目经验</title>
    <link href="/2023/02/15/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C/"/>
    <url>/2023/02/15/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a>项目经验</h1><h2 id="一、npm引入双包做实验"><a href="#一、npm引入双包做实验" class="headerlink" title="一、npm引入双包做实验"></a>一、npm引入双包做实验</h2><p>可引入一个包的不同版本做AB实验，实验内使用新包，实验外使用旧包</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-string">&quot;package&quot;</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>,<br><span class="hljs-string">&quot;package-new&quot;</span>: <span class="hljs-string">&quot;npm:package@1.0.1&quot;</span>,<br></code></pre></td></tr></table></figure><h2 id="二、动态引入外部包：import和import"><a href="#二、动态引入外部包：import和import" class="headerlink" title="二、动态引入外部包：import和import()"></a>二、动态引入外部包：import和import()</h2><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p><code>import</code>语句会被js引擎静态分析，先于模块内的其他模块执行。所以，下面这种代码会报错</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">if</span> (x === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">import</span> otherMoudle <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./otherMoudle&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>引擎处理<code>import</code>语句是在编译时，而if语句这类是运行时处理，所以<code>import</code>语句放在if代码块内会报语法错误。也就是说<code>import</code>和<code>export</code>命令只能在模块的顶层，而不能在代码块之中。</p><p>这样设计有助于提高编译效率，但也导致无法在运行时加载模块，即不能根据业务条件加载，可能会导致包体积过大。因此引入import()函数，支持动态加载。</p><h3 id="import-1"><a href="#import-1" class="headerlink" title="import()"></a>import()</h3><p><code>import()</code>类似node中的require，是在运行时加载模块，即可以实现动态加载。区别主要在于<code>import()</code>是<code>异步加载</code>，<code>require</code>是<code>同步加载</code>;</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;sdkPackage&#x27;</span>).then(sdk =&gt; &#123;<br>    <span class="hljs-keyword">const</span> sdkInstanse = <span class="hljs-keyword">new</span> sdk.<span class="hljs-keyword">default</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><p>ES6 import()返回一个Promise对象，以上是一个例子。<code>import()</code>函数可以用在任何地方，不仅仅是模块，也可以是非模块的脚本。下面是<code>import()</code>的一些适用场合。</p><h4 id="（1）按需加载"><a href="#（1）按需加载" class="headerlink" title="（1）按需加载"></a>（1）按需加载</h4><p>import()可以在需要的时候在加载某个模块</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart">button.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, event =&gt; &#123;<br>    <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./dialogBox.js&#x27;</span>).then(dialogBox =&gt; &#123;<br>        dialogBox.open();<br>    &#125;).<span class="hljs-keyword">catch</span>(error =&gt; &#123;<br>        <span class="hljs-comment">/* Error handling */</span><br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>比如以上代码，<code>import()</code>方法放在click事件的监听函数中，只有用户点击了按钮才会加载这个模块。</p><h4 id="（2）条件加载"><a href="#（2）条件加载" class="headerlink" title="（2）条件加载"></a>（2）条件加载</h4><p><code>import()</code>可以放在if等代码块中，根据不同的条件加载不同的模块。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">if</span> (condition) &#123;<br>    <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;moduleA&#x27;</span>).then(<span class="hljs-params">...</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;moduleB&#x27;</span>).then(<span class="hljs-params">...</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，根据是否满足condition，条件加载模块A或者模块B。</p><h4 id="（3）动态的模块路径"><a href="#（3）动态的模块路径" class="headerlink" title="（3）动态的模块路径"></a>（3）动态的模块路径</h4><p><code>import()</code>加载的内容可以是动态生成的路径。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">import</span>(fn())<span class="hljs-selector-class">.then</span>(...);<br></code></pre></td></tr></table></figure><p>上面代码中，import()的内容是一个函数，可以根据函数fn的返回结果，加载不同的模块。</p>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>踩坑记录</title>
    <link href="/2022/11/17/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/11/17/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>常用工具</p><h1 id="css动画"><a href="#css动画" class="headerlink" title="css动画"></a>css动画</h1><p>卡顿：尽量避免使用margin、padding、left、right等来transform，更推荐使用translate、scale</p><h1 id="二维码解析"><a href="#二维码解析" class="headerlink" title="二维码解析"></a>二维码解析</h1><p>个别解析失败问题：todo</p>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css经验</title>
    <link href="/2022/11/04/css%E7%BB%8F%E9%AA%8C/"/>
    <url>/2022/11/04/css%E7%BB%8F%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="css经验"><a href="#css经验" class="headerlink" title="css经验"></a>css经验</h1><h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h2><p>css渐变属性：linear-gradient</p><h3 id="渐变抗锯齿"><a href="#渐变抗锯齿" class="headerlink" title="渐变抗锯齿"></a>渐变抗锯齿</h3><p>锯齿现象：锯齿现象在DPR为1（如ios）的屏幕下特别明显，在dpr&gt;1的高清屏上则相较不明显。<br>锯齿产生原因：网页呈现是基于像素单位的，在一种颜色直接过渡到另外一种颜色时，容易导致可视质量下降。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">37deg</span>), <span class="hljs-number">#000</span> <span class="hljs-number">50%</span>, <span class="hljs-number">#f00</span> <span class="hljs-number">50%</span>, <span class="hljs-number">#f00</span>);<br></code></pre></td></tr></table></figure><p>比如以上代码在50%的地方从#000直接过渡到#f00，仔细看即可看到过渡处的锯齿。<br><img src="/images/css%E7%BB%8F%E9%AA%8C/1.png" alt="1"></p><h3 id="简单的解决方法"><a href="#简单的解决方法" class="headerlink" title="简单的解决方法"></a>简单的解决方法</h3><p>最简单的就是<b>不要直接过渡</b>。将上述代码从50%-50%的直接过渡，改成预留了1%的渐变过渡空间</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">background</span>: linear-gradient(<span class="hljs-number">37</span>deg), #<span class="hljs-number">000</span> <span class="hljs-number">49</span>.<span class="hljs-number">5</span>%, #f00 <span class="hljs-number">49</span>.<span class="hljs-number">5</span>%, #f00);<br></code></pre></td></tr></table></figure><p>即可有效处理过渡处的锯齿问题。改造后效果如下：<br><img src="/images/css%E7%BB%8F%E9%AA%8C/2.png" alt="2"></p><h2 id="css实现文字滚动"><a href="#css实现文字滚动" class="headerlink" title="css实现文字滚动"></a>css实现文字滚动</h2><p>css属性： animation、@keyframes、transform</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">set<span class="hljs-constructor">Animation()</span> &#123;<br>    this.<span class="hljs-constructor">$nextTick(()</span> =&gt; &#123;<br>        const textDom = this.$refs.text;<br>        const canScroll = textDom?.clientWidth &lt; textDom?.scrollWidth;<br>        <span class="hljs-keyword">if</span> (canScroll) &#123;<br>            const styleEl = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">style</span>&#x27;)</span>;<br>            styleEl.id = &#x27;textKeyframe&#x27;;<br>            document.head.append<span class="hljs-constructor">Child(<span class="hljs-params">styleEl</span>)</span>;<br>            const textKeyframe = `<br>                @keyframes wordsLoop &#123;<br>                    <span class="hljs-number">0</span>% &#123;<br>                        transform: translate<span class="hljs-constructor">X(0px)</span><br>                    &#125;<br>                    <span class="hljs-number">10</span>% &#123;<br>                        transform: translate<span class="hljs-constructor">X(0px)</span>;<br>                    &#125;<br>                    <span class="hljs-number">90</span>% &#123;<br>                        transform: translate<span class="hljs-constructor">X($&#123;<span class="hljs-params">textDom</span>?.<span class="hljs-params">clientWidth</span> - <span class="hljs-params">textDom</span>?.<span class="hljs-params">scrollWidth</span>&#125;<span class="hljs-params">px</span>)</span><br>                    &#125;<br>                    <span class="hljs-number">100</span>% &#123;<br>                        transform: translate<span class="hljs-constructor">X($&#123;<span class="hljs-params">textDom</span>?.<span class="hljs-params">clientWidth</span> - <span class="hljs-params">textDom</span>?.<span class="hljs-params">scrollWidth</span>&#125;<span class="hljs-params">px</span>)</span><br>                    &#125;<br>                &#125;<br>            `;<br>            styleEl.sheet.insert<span class="hljs-constructor">Rule(<span class="hljs-params">textKeyframe</span>, 0)</span>;<br>            this.appTextStyle = &#123;<br>                animation: &#x27;wordsLoop <span class="hljs-number">3</span>s linear alternate infinite&#x27;,<br>                &#x27;-webkit-animation&#x27;: &#x27;wordsLoop <span class="hljs-number">3</span>s linear alternate infinite&#x27;<br>            &#125;;<br>        &#125;<br>    &#125;);<br>&#125;,<br></code></pre></td></tr></table></figure><p>滚动的核心动画为@keyframes部分，是否要用动态插入的方式具体要看滚动的规则是怎样的。如果需要根据文本长度动态计算，则可能需要使用动态插入的方式。</p><h3 id="动态插入个别机型不兼容问题"><a href="#动态插入个别机型不兼容问题" class="headerlink" title="动态插入个别机型不兼容问题"></a>动态插入个别机型不兼容问题</h3><p>如果动态插入的动画在个别机型上不动，需要格外注意该<b>动画样式被使用时是不是已经存在</b>。<br>比如上述代码，是先生成了wordsLoop这个keyframes并插入到样式表之后，再通过appTextStyle使用了wordsLoop。使用wordsLoop时wordsLoop是已经存在样式表中的。<br>如果将appTextStyle中的animation部分直接写在css文件中，那么代码初始运行时，wordsLoop还未生成，样式表中还没有该keyframes。即便后面生成插入了，但可能在有的机型上会不兼容不能展示动画。</p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图片引入与iconfont使用</title>
    <link href="/2022/10/12/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/10/12/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="图片引入与iconfont使用"><a href="#图片引入与iconfont使用" class="headerlink" title="图片引入与iconfont使用"></a>图片引入与iconfont使用</h1><h2 id="图片引入"><a href="#图片引入" class="headerlink" title="图片引入"></a>图片引入</h2><p>日常项目开发中，通常ue图中用到的图片ue会给我们切图，我们需要把图使用到代码中，通常使用的引入图片方式有：</p><ol><li>把图片放到代码库的静态资源中。<ul><li>优点：打包进产出，加载后运行时显示快</li><li>缺点：增大打包体积，影响包加载速度</li></ul></li><li>图片上传cdn，生成cdn链接使用url引入<ul><li>优点：可以替换cdn资源来更换图片内容，可以根据拦截器进行权限控制，可以缓存，不影响包体积情况下加载速度也很不错，是最常用的方式</li><li>缺点：需要考虑一些特殊场景，比如svg图片通过url引入使用image标签时，在ios上会很模糊</li></ul></li><li>图标类通过iconfont转base64使用<ul><li>优点：减少图片的http请求</li><li>缺点：base64相当于把字符串直接写在代码文件中，也会增加代码打包体积，一般只在加载小图标时使用</li></ul></li></ol><h2 id="iconfont使用"><a href="#iconfont使用" class="headerlink" title="iconfont使用"></a>iconfont使用</h2><h3 id="1-将要使用的图片上传至iconfont"><a href="#1-将要使用的图片上传至iconfont" class="headerlink" title="1.将要使用的图片上传至iconfont"></a>1.将要使用的图片上传至iconfont</h3><p><img src="/images/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/1.png" alt="1"><br>上传时可能需要几分钟审核，等待一段时间即可</p><h3 id="2-下载图标代码"><a href="#2-下载图标代码" class="headerlink" title="2.下载图标代码"></a>2.下载图标代码</h3><p>审核通过成功上传后，将图标添加进购物车，然后进购物车下载代码<br><img src="/images/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/2.png" alt="2"></p><p><img src="/images/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/3.png" alt="3"></p><h3 id="3-获取iconfont代码文件"><a href="#3-获取iconfont代码文件" class="headerlink" title="3.获取iconfont代码文件"></a>3.获取iconfont代码文件</h3><p>下载成功后，得到一个压缩文件，解压如下<br><img src="/images/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/4.png" alt="4"></p><h3 id="4-将下载的tff文件转换为base64格式"><a href="#4-将下载的tff文件转换为base64格式" class="headerlink" title="4.将下载的tff文件转换为base64格式"></a>4.将下载的tff文件转换为base64格式</h3><p>推荐使用网站：<a href="https://transfonter.org/">https://transfonter.org</a></p><p>按下图配置选项，打开 Base64 encode 选项：<br><img src="/images/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/5.png" alt="5"></p><p>配置完后，添加tff文件，开始转换<br><img src="/images/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/6.png" alt="6"></p><p>转换成功后，点击下载<br><img src="/images/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/7.png" alt="7"></p><p>下载得到压缩文件，解压后会有一个stylesheet.css的css文件<br><img src="/images/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/8.png" alt="8"></p><p>该css文件的字体地址就是base64了<br><img src="/images/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/9.png" alt="9"></p><h3 id="5-在项目中使用"><a href="#5-在项目中使用" class="headerlink" title="5.在项目中使用"></a>5.在项目中使用</h3><p>将上一步得到的css文件代码中的@font-face部分复制至代码中<br>以及第3步iconfont上下载得到的iconfont.css文件中的样式部分复制至代码中<br>最后项目里的css文件如下：<br><img src="/images/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/10.png" alt="10"></p><p>使用的地方：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;iconfont icon-back&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Reference-Document"><a href="#Reference-Document" class="headerlink" title="Reference Document"></a>Reference Document</h2><p><a href="https://www.tytrock.com/topics/327">阿里巴巴 iconfont 字体转 base64 并引入使用</a></p>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack入门</title>
    <link href="/2022/10/11/webpack%E5%85%A5%E9%97%A8/"/>
    <url>/2022/10/11/webpack%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>1.生成package.json文件</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> init<br></code></pre></td></tr></table></figure><p>2.安装webpack</p>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2022/10/11/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2022/10/11/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<p>二分查找</p><h1 id="基本二分查找"><a href="#基本二分查找" class="headerlink" title="基本二分查找"></a>基本二分查找</h1><h1 id="二分查找要点"><a href="#二分查找要点" class="headerlink" title="二分查找要点"></a>二分查找要点</h1><h2 id="如何确定循环结束条件"><a href="#如何确定循环结束条件" class="headerlink" title="如何确定循环结束条件"></a>如何确定循环结束条件</h2><h2 id="区间如何收缩"><a href="#区间如何收缩" class="headerlink" title="区间如何收缩"></a>区间如何收缩</h2><h2 id="如何确定返回值"><a href="#如何确定返回值" class="headerlink" title="如何确定返回值"></a>如何确定返回值</h2><h2 id="Reference-Document"><a href="#Reference-Document" class="headerlink" title="Reference Document"></a>Reference Document</h2><p><a href="https://www.cnblogs.com/labuladong/p/12320448.html">https://www.cnblogs.com/labuladong/p/12320448.html</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用工具</title>
    <link href="/2022/10/08/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    <url>/2022/10/08/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<p>常用工具</p><h1 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h1><p>npm包查询：<a href="https://bundlephobia.com/">https://bundlephobia.com/</a><br>npm包比较：<a href="https://npmtrends.com/">https://npmtrends.com/</a></p><h1 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h1>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用命令</title>
    <link href="/2022/10/08/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/10/08/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>常用命令</p><h1 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm cache clean -f <span class="hljs-regexp">//</span> 清除npm缓存<br></code></pre></td></tr></table></figure><h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用js移位运算符取整</title>
    <link href="/2022/09/28/%E4%BD%BF%E7%94%A8js%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%96%E6%95%B4/"/>
    <url>/2022/09/28/%E4%BD%BF%E7%94%A8js%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%96%E6%95%B4/</url>
    
    <content type="html"><![CDATA[<p>使用js移位运算符取整</p><h1 id="运算符介绍"><a href="#运算符介绍" class="headerlink" title="运算符介绍"></a>运算符介绍</h1><h2 id="有符号右移"><a href="#有符号右移" class="headerlink" title="有符号右移"></a>有符号右移</h2><p><code>&gt;&gt;</code>该操作符会将指定操作数的二进制位向右移动指定的位数。<b>向右被移出的位被丢弃，拷贝最左侧的位以填充左侧。</b>由于新的最左侧的位总是和以前相同，符号位没有被改变。</p><h2 id="无符号右移"><a href="#无符号右移" class="headerlink" title="无符号右移"></a>无符号右移</h2><p><code>&gt;&gt;&gt;</code>该操作符会将第1个操作数向右移动指定的位数。<b>向右被移出的位被丢弃，左侧用0填充。</b>因为符号位变成了0，所以结果总是非负的.</p><h1 id="妙用"><a href="#妙用" class="headerlink" title="妙用"></a>妙用</h1><h2 id="用于取整"><a href="#用于取整" class="headerlink" title="用于取整"></a>用于取整</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">console</span>.log(<span class="hljs-number">3</span>.<span class="hljs-number">14</span> &gt;&gt; <span class="hljs-number">0</span>)  // <span class="hljs-number">3</span><br><span class="hljs-attribute">console</span>.log(<span class="hljs-number">3</span>.<span class="hljs-number">14</span> &gt;&gt;&gt; <span class="hljs-number">0</span>)  // <span class="hljs-number">3</span> (不可对负数取整)<br></code></pre></td></tr></table></figure><h2 id="用于获取除2之后的整数"><a href="#用于获取除2之后的整数" class="headerlink" title="用于获取除2之后的整数"></a>用于获取除2之后的整数</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">console</span>.log(<span class="hljs-number">5</span> &gt;&gt; <span class="hljs-number">1</span>)  // <span class="hljs-number">2</span><br><span class="hljs-attribute">console</span>.log(<span class="hljs-number">4</span> &gt;&gt; <span class="hljs-number">1</span>)  // <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2022/07/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/07/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>设计模式的分类及应用</p><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h1 id="订阅发布模式"><a href="#订阅发布模式" class="headerlink" title="订阅发布模式"></a>订阅发布模式</h1>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/07/22/hello-world/"/>
    <url>/2022/07/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>This website is designed by hexo &amp; fluid, please refer to the following documents for how to use it.</p><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info:<br><a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a><br><a href="https://blog.csdn.net/yaorongke/article/details/119089190">Reference Document</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
