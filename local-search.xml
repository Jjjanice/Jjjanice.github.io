<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>测试经验</title>
    <link href="/2023/05/15/%E6%B5%8B%E8%AF%95%E7%BB%8F%E9%AA%8C/"/>
    <url>/2023/05/15/%E6%B5%8B%E8%AF%95%E7%BB%8F%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<p>测试经验</p><h1 id="charles修改clientip"><a href="#charles修改clientip" class="headerlink" title="charles修改clientip"></a>charles修改clientip</h1><p>使用rewrite修改接口的入参和返回。</p><p><a href="https://blog.csdn.net/weixin_44330336/article/details/122843706">https://blog.csdn.net/weixin_44330336/article/details/122843706</a></p>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>闭包</title>
    <link href="/2023/04/29/%E9%97%AD%E5%8C%85/"/>
    <url>/2023/04/29/%E9%97%AD%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<p>闭包</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>通过前面作用域和作用域链的学习，我们可以知道，JavaScript中作用域分为全局作用域和局部作用域，与之对应的就是全局变量和局部变量。</p><p>且js的的作用域链使得局部作用域内可以直接读取全局变量。但在局部作用域外部自然无法读取局部作用域内部的局部变量。<b>也即函数内部可以直接读取全局变量，但函数外部无法直接读取函数内的局部变量。</b></p><p>出于一些原因，我们有时候会需要拿到函数内的局部变量。如前面所说，正常情况下是拿不到的，但是在一种特殊情况下可以做到：那就是再函数内部，再定义一个函数。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">var</span> n = <span class="hljs-number">99</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> n; <span class="hljs-comment">// 999</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上例，由于f2在f1内部，此时f1内部的所有局部变量对f2都是可见的，但是反之不行。</p><p>但是既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，那我们就可以在f1外部访问f1内部的局部变量了。</p><h1 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h1><p>如上所示，这种<b>能够读取其他函数内部变量的函数我们称之为”闭包”，它一般是定义在一个函数内部的函数，充当将函数内部与函数外部连接起来的一座桥梁。</b></p><h1 id="闭包的使用场景"><a href="#闭包的使用场景" class="headerlink" title="闭包的使用场景"></a>闭包的使用场景</h1><p>闭包最大的用途有2个：</p><ul><li><ol><li>可以读取函数内部的局部变量</li></ol></li><li><ol start="2"><li>让函数内部的变量始终保持再内存当中</li></ol></li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">calcuNumber</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<br>    addNumber = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        n += <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">getNumber</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(n);<br>    &#125;<br>    <span class="hljs-keyword">return</span> getNumber;<br>&#125;<br><span class="hljs-keyword">var</span> getNumber = calcuNumber();<br>getNumber(); <span class="hljs-comment">// 999</span><br>addNumber();<br>getNumber(); <span class="hljs-comment">// 1000</span><br></code></pre></td></tr></table></figure><p>如上例，getNumber和addNumber都是闭包函数，只是getNumber为calcuNumber中返回的函数，addNumber为全局声明但在函数内部定义的一个函数，本质两个都是函数内部的函数，且能访问函数内部的变量。<br>且从两次getNumber的调用我们可以看出来，函数f1中的局部变量n一直保存在内存中，并没有再f1调用后被自动清楚。这是因为，calcuNumber是getNumber的父函数，而getNumber被赋予了一个全局变量，这导致getNumber始终在内存中，而getNumber的存在依赖于calcuNumber，所以calcuNumber也始终再内存中，不会在调用结束后被垃圾回收机制回收。</p><h1 id="闭包的原理"><a href="#闭包的原理" class="headerlink" title="闭包的原理"></a>闭包的原理</h1><p>作用域和作用域链相关</p><h1 id="使用闭包的注意事项"><a href="#使用闭包的注意事项" class="headerlink" title="使用闭包的注意事项"></a>使用闭包的注意事项</h1><ul><li><ol><li><b>注意不要随便改变父函数内部的变量值。</b> 由于闭包会在父函数外部改变父函数内部变量的值，所以容易错乱。<blockquote><p>解决方法： 把父函数当对象使用，把闭包当做父函数的公用方法，把内部变量当做父函数的<b>私有属性</b>。</p></blockquote></li></ol></li><li><ol start="2"><li><b>闭包可能导致性能问题和内存泄露。</b>由于闭包会使得函数中的变量都被保存在内存中，内存消耗会很大，所以不能滥用闭包，否则会造成网页的性能问题，还可能导致内存泄露。</li></ol></li></ul><blockquote><p>解决方法： 在退出函数之前，将不使用的全局变量删除。</p></blockquote><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>阮一峰：<a href="https://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html">https://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>this指向</title>
    <link href="/2023/04/21/this%E6%8C%87%E5%90%91/"/>
    <url>/2023/04/21/this%E6%8C%87%E5%90%91/</url>
    
    <content type="html"><![CDATA[<p>this指向</p><p>由《执行上下文栈》我们可知JavaScript每执行一段可执行代码时，都会创建对应的执行上下文。</p><p>对于每个执行上下文，都有三个重要属性：</p><ul><li>变量对象</li><li>作用域链</li><li>this</li></ul><p>本篇主要介绍this。</p><h1 id="不同调用场景下的this"><a href="#不同调用场景下的this" class="headerlink" title="不同调用场景下的this"></a>不同调用场景下的this</h1><p>首先需要明确的是，不像函数作用域是在函数定义的时候就确定了，this的指向在函数定义的时候是无法确定的，只有函数执行的时候才能确定this到底指向谁。</p><p>在非箭头函数下，this想象调用其所在函数的对象，而且是离谁近就指向谁（此对于常规对象、原型链、getter&amp;setter等都适用）；构造函数下，this与被创建的新对象绑定；DOM事件中，this指向触发事件的元素；还有内联事件、延时函数、箭头函数等情况，我们分开展开以下讨论。</p><h1 id="全局环境"><a href="#全局环境" class="headerlink" title="全局环境"></a>全局环境</h1><p>在全局环境下，无论是否严格模式，this始终指向全局对象（window）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在浏览器中，全局对象为window对象</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> === <span class="hljs-variable language_">window</span>); <span class="hljs-comment">// true</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">document</span> === <span class="hljs-variable language_">window</span>); <span class="hljs-comment">// true</span><br><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = <span class="hljs-number">2</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">a</span>); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><h1 id="函数上下文调用中的this"><a href="#函数上下文调用中的this" class="headerlink" title="函数上下文调用中的this"></a>函数上下文调用中的this</h1><h2 id="函数直接调用"><a href="#函数直接调用" class="headerlink" title="函数直接调用"></a>函数直接调用</h2><p>普通函数内部的this分【严格模式】和【非严格模式】两种情况。</p><p>非严格模式下，this默认指向全局对象window</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">thisl</span><br>&#125;<br><br>console.log(f1() === window); // <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>严格模式下，this默认为undefined</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-string">&quot;use strict&quot;</span>;<br>    <span class="hljs-keyword">return</span> this;<br>&#125;<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(f2() === <span class="hljs-literal">undefined</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="对象中的this"><a href="#对象中的this" class="headerlink" title="对象中的this"></a>对象中的this</h2><p><b>对象内部方法的this指向调用这些方法的对象。</b>注意：</p><ol><li><p><b>函数的定义无法确定this的指向，this指向只与调用函数的对象有关。</b></p></li><li><p><b>多层嵌套的对象，内部方法的this指向离被调用函数最近的对象。</b></p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>,<br>    <span class="hljs-attr">b</span>: &#123;<br>        <span class="hljs-attr">a</span>: <span class="hljs-number">12</span>,<br>        <span class="hljs-attr">fn</span>: <span class="hljs-title function_">funtion</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>); <span class="hljs-comment">// 12</span><br>        &#125;<br>    &#125;<br>&#125;<br>o.<span class="hljs-property">b</span>.<span class="hljs-title function_">fn</span>();<br></code></pre></td></tr></table></figure><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> o = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>,<br>    <span class="hljs-attr">b</span>: &#123;<br>        <span class="hljs-attr">a</span>: <span class="hljs-number">12</span>,<br>        <span class="hljs-attr">fn</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.a); <span class="hljs-comment">// undefined</span><br>            <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this); <span class="hljs-comment">// window</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> j = o.b.fn;<br>j();<br></code></pre></td></tr></table></figure><p>第一个例子中的this指向离 被调用函数fn 最近的对象，也就是对象b，所以打印出来的this.a就是12.</p><p>第二个例子中，虽然函数fn是对象b的一个方法，但是在将fn赋值给j的时候并没有执行，被赋值后的j就是fn函数。而变量j是window的属性，所以当后面调用j()的时候指向的就是window。</p><h2 id="原型链中的this"><a href="#原型链中的this" class="headerlink" title="原型链中的this"></a>原型链中的this</h2><p><b>原型链中的方法的this仍然是指向调用它的对象。</b></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o = &#123;<br>    <span class="hljs-attr">f</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">var</span> p = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(o);<br>p.<span class="hljs-property">a</span> = <span class="hljs-number">1</span>;<br>p.<span class="hljs-property">b</span> = <span class="hljs-number">4</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-title function_">f</span>()); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p>上例中，虽然p中没有属性f，但是当在执行p.f()时，会查找p的原型链，找到f函数并执行，这个时候是p调用f函数。以上对于函数作为getter和setter时同样适用。</p><h2 id="构造函数中的this"><a href="#构造函数中的this" class="headerlink" title="构造函数中的this"></a>构造函数中的this</h2><p><b>构造函数的this与新创建的新对象绑定。</b></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"> &#123;</span><br><span class="hljs-params">    <span class="hljs-variable language_">this</span>.user = <span class="hljs-string">&#x27;jjj&#x27;</span>;</span><br><span class="hljs-params">&#125;</span>)<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title function_">fn</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a.<span class="hljs-property">user</span>); <span class="hljs-comment">// jjj</span><br></code></pre></td></tr></table></figure><p>这里为什么新创建的对象a能读到构造函数fn内的属性呢？这其实涉及到new关键字，我们搞清楚new关键字到底做了什么，就能理解了，接下来我们看一下new关键字做了什么。</p><h3 id="new关键字"><a href="#new关键字" class="headerlink" title="new关键字"></a>new关键字</h3><p>以以下这个构造函数为例:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(name, age)</span> &#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>    <span class="hljs-keyword">this</span>.age = age;<br>&#125;<br></code></pre></td></tr></table></figure><p>new关键字在创建实例对象时，主要经历了以下4个过程：</p><ul><li><ol><li>首先创建一个空对象<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-keyword">let</span> <span class="hljs-attr">obj</span> = &#123;&#125;&#x27;<br></code></pre></td></tr></table></figure></li></ol></li><li><ol start="2"><li>实例对象obj的隐式原型要与构造函数Person的显式原型指向相同<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">obj._proto_</span> = Person.prototype<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ol></li><li><ol start="3"><li>将构造函数Person内部的this与实例对象obj做绑定，并对构造函数内部的值做一个赋值操作。</li></ol></li><li><ol start="4"><li>根据构造函数的返回值类型确定新创建的实例对象的具体值。若构造函数的返回值是引用类型（Object、Array、Function）的，那么我们新创建的实例对象就是该返回值；若返回值存在但不为引用类型，或者没有返回值(如上例)，那么新创建的对象就是构造函数实例。</li></ol></li></ul><p>通过了解new关键字实例化对象的过程，我们可以很清楚的知道为什么构造函数的this会与新创建的新对象绑定了。</p><h3 id="构造函数中有return时"><a href="#构造函数中有return时" class="headerlink" title="构造函数中有return时"></a>构造函数中有return时</h3><p>返回为对象</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>    this.user = <span class="hljs-string">&#x27;jjj&#x27;</span>;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">user</span>: <span class="hljs-string">&#x27;aaa&#x27;</span>&#125;;<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> fn();<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a.user); <span class="hljs-comment">// aaa</span><br></code></pre></td></tr></table></figure><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>    this.user = <span class="hljs-string">&#x27;jjj&#x27;</span>;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> fn();<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a.user); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>返回为函数</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>    this.user = <span class="hljs-string">&#x27;jjj&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;;<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> fn();<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a.user); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>返回为非引用类型</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>    this.user = <span class="hljs-string">&#x27;jjj&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// return undefined;</span><br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> fn();<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a.user); <span class="hljs-comment">// jjj</span><br></code></pre></td></tr></table></figure><p>这几个例子说明了new关键字在实例化对象时第4步所做的事。值得注意的一点时，虽然null也是对象，但如果构造函数返回了null，这个时候的this还是指向那个函数的实例，null比较特殊。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>    this.user = <span class="hljs-string">&#x27;jjj&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> fn();<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a.user); <span class="hljs-comment">// jjj</span><br></code></pre></td></tr></table></figure><h1 id="DOM事件处理函数"><a href="#DOM事件处理函数" class="headerlink" title="DOM事件处理函数"></a>DOM事件处理函数</h1><p>当函数被当作<b>监听事件处理函数</b>时，其this指向触发该事件的元素（<b>针对addEventListener事件</b>）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 被调用时，将关联的元素变成蓝色</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bluify</span>(<span class="hljs-params">e</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">//在控制台打印出所点击元素</span><br>  e.<span class="hljs-title function_">stopPropagation</span>();  <span class="hljs-comment">//阻止时间冒泡</span><br>  e.<span class="hljs-title function_">preventDefault</span>(); <span class="hljs-comment">//阻止元素的默认事件    </span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">style</span>.<span class="hljs-property">backgroundColor</span> = <span class="hljs-string">&#x27;#A5D9F3&#x27;</span>;<br>&#125;<br><span class="hljs-comment">// 获取对应元素进行监听</span><br><span class="hljs-keyword">var</span> el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElemenById</span>(<span class="hljs-string">&#x27;should-bluify&#x27;</span>);<br><br><span class="hljs-comment">// 将bluify作为元素的点击监听函数，当元素被点击时，就会变成蓝色</span><br>el.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, bluify, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><p>在以上例子中，作为监听事件处理函数的bluify函数中的this就指向el元素。</p><h1 id="内联事件"><a href="#内联事件" class="headerlink" title="内联事件"></a>内联事件</h1><p>内联事件中的this分两种情况：</p><ul><li><ol><li>当代码被内联处理函数调用时，它指向监听器所在的DOM元素</li></ol></li><li><ol start="2"><li>当代码被包括在函数内部执行时，其this指向等同于函数直接调用的情况，即非严格模式指向全局对象window，严格模式指向undefined。</li></ol></li></ul><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs hsp">&lt;<span class="hljs-keyword">button</span> <span class="hljs-keyword">onclick</span>=<span class="hljs-string">&quot;console.log(this);&quot;</span>&gt;show me&lt;/<span class="hljs-keyword">button</span>&gt; <span class="hljs-comment">// 打印出该button元素</span><br>&lt;<span class="hljs-keyword">button</span> <span class="hljs-keyword">onclick</span>=<span class="hljs-string">&quot;(function() &#123;console.log(this)&#125;)()&quot;</span>&gt;show inner this&lt;/<span class="hljs-keyword">button</span>&gt; <span class="hljs-comment">// 打印window对象</span><br>&lt;<span class="hljs-keyword">button</span> <span class="hljs-keyword">onclick</span>=<span class="hljs-string">&quot;(function() &#123;&quot;</span>use strict<span class="hljs-string">&quot;; console.log(this)()&#125;)&quot;</span>&gt;show inner this uer strict&lt;/<span class="hljs-keyword">button</span>&gt; <span class="hljs-comment">// 打印undefined</span><br><br></code></pre></td></tr></table></figure><h1 id="setTimeOut-amp-setInterval"><a href="#setTimeOut-amp-setInterval" class="headerlink" title="setTimeOut &amp; setInterval"></a>setTimeOut &amp; setInterval</h1><p>对于延时函数内部的回调函数的this指向全局对象window。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//默认情况下代码</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;  <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">0</span>;  <br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<span class="hljs-comment">// 打印出window对象</span><br>    &#125;, <span class="hljs-number">3000</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<span class="hljs-comment">//3秒后返回 window 对象</span><br></code></pre></td></tr></table></figure><blockquote><p style="color: red">疑问？为什么如果在setTimeOut中打印this.a，能正确打印出来呢，this不是window对象吗</p></blockquote><p>当然也可以用过bing方法改变其内部函数的this指向</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//通过bind绑定</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;  <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">0</span>;  <br>    <span class="hljs-built_in">setTimeout</span>((<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<span class="hljs-comment">// 打印出Person对象</span><br>    &#125;).<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>), <span class="hljs-number">3000</span>);<br>&#125;<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(); <span class="hljs-comment">//3秒后返回构造函数新生成的对象 Person&#123;...&#125;</span><br></code></pre></td></tr></table></figure><h1 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h1><p>箭头函数不绑定this，它会捕获其所在的上下文的this值，作为自己的this值。需要注意的是：</p><ul><li><ol><li>call()、apply()、bing()方法对于箭头函数来说只是传入参数，对它的this毫无影响</li></ol></li><li><ol start="2"><li>考虑到箭头函数的this是词法层面的，可以忽略是否是严格模式对this的影响</li></ol></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;  <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">0</span>;  <br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// Person对象</span><br>    &#125;, <span class="hljs-number">3000</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;  <br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">0</span>;  <br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>) <span class="hljs-comment">// Window对象</span><br>    &#125;, <span class="hljs-number">3000</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br></code></pre></td></tr></table></figure><p>验证严格模式影响</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<span class="hljs-string">&#x27;use strict&#x27;</span>; <span class="hljs-keyword">return</span> this&#125;;<br><span class="hljs-keyword">var</span> p = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; <span class="hljs-keyword">return</span> this&#125;;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>,f() === window); <span class="hljs-comment">//true</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>,f() === p()); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>为什么说箭头函数的this是词法层面的呢？我们可以看以下的例子：</p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">var</span> obj = &#123;<br>  i: <span class="hljs-number">10</span>,<br>  b: () =&gt; console.log(this.i, this),<br>  c: function() &#123;<br>    console.log( this.i, this)<br>  &#125;<br>&#125;<br>obj.b();  // undefined window<span class="hljs-meta">&#123;...&#125;</span><br>obj.c();  // <span class="hljs-number">10</span> <span class="hljs-type">Object</span> <span class="hljs-meta">&#123;...&#125;</span><br></code></pre></td></tr></table></figure><p>我们可以看到obj.b()打印出来的this指向了window，这是因为指向了当前的执行上下文，捕获了当前上下文的this作为自己的this，而此时当前上下文的this就是window。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/dongcanliang/p/7054176.html">https://www.cnblogs.com/dongcanliang/p/7054176.html</a><br><a href="https://www.cnblogs.com/jsunwang/p/13393353.html">https://www.cnblogs.com/jsunwang/p/13393353.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>变量对象、函数提升与变量提升</title>
    <link href="/2023/04/20/%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E3%80%81%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87%E4%B8%8E%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/"/>
    <url>/2023/04/20/%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%E3%80%81%E5%87%BD%E6%95%B0%E6%8F%90%E5%8D%87%E4%B8%8E%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87/</url>
    
    <content type="html"><![CDATA[<p>变量对象、函数提升与变量提升</p><p>由《执行上下文栈》我们可知JavaScript每执行一段可执行代码时，都会创建对应的执行上下文。</p><p>对于每个执行上下文，都有三个重要属性：</p><ul><li>变量对象</li><li>作用域链</li><li>this</li></ul><p>本篇主要介绍变量对象以及变量对象创建的过程。</p><h1 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h1><p>变量对象是<b>与执行上下文相关的数据作用域</b>，存储了在上下文中定义的变量对象和函数声明。</p><p>因为不同执行上下文的变量对象稍有不同，我们主要讲下 全局上下文和函数上下文 下的变量对象。</p><h1 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h1><blockquote><p>在顶层JavaScript代码中，可以用关键字this引用全局对象。因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。</p></blockquote><p>全局对象我们都不陌生了，我们来进一步介绍下：</p><ol><li><p>可以通过this引用，在客户端JavaScript中，全局对象就是Window对象。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">console.log(this <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> window)<span class="hljs-comment">; // 在顶层JavaScript打印，结果为true，控制台可验证</span><br></code></pre></td></tr></table></figure></li><li><p>全局对象是由Object构造函数实例化的一个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></li><li><p>预定义一堆函数和属性，比如Date、Math、Number、String等这些内置函数。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(Math.<span class="hljs-built_in">random</span>()); <span class="hljs-comment">// 能正常打印，不会报错，因为预定义了</span><br></code></pre></td></tr></table></figure></li><li><p>作为全局变量的诉诸，全局变量都存储在这里。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.a); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure></li><li><p>客户端JavaScript中，全局对象有window对象指向自身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">a</span>); <span class="hljs-comment">// 1</span><br><br><span class="hljs-variable language_">this</span>.<span class="hljs-property">window</span>.<span class="hljs-property">b</span> = <span class="hljs-number">2</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">b</span>); <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure></li></ol><p>通过以上几个点，我们可以很明确的知道：<b>全局上下文的变量对象就是全局对象。</b></p><h1 id="函数上下文"><a href="#函数上下文" class="headerlink" title="函数上下文"></a>函数上下文</h1><p>在函数上下文中，我们用活动对象（Activation Object，AO）来表示变量对象。</p><p>活动对象可以说是处于激活状态的变量对象，只有当进入一个执行上下文中时，这个执行上下文的变量对象才会被激活，成为活动对象。只有被激活的变量对象也就是活动对象上的各种属性才能被访问。</p><p>活动对象是在进入函数上下文时被创建的，它通过函数的arguments属性初始化，arguments属性值是Arguments。</p><h1 id="代码执行过程"><a href="#代码执行过程" class="headerlink" title="代码执行过程"></a>代码执行过程</h1><p>执行上下文的代码会分两个阶段处理：<b>分析和执行</b></p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>当进入执行上下文时，这是很好还没有执行代码，变量对象包括</p><ol><li>函数的所有<b>形参</b>（针对函数上下文）<ul><li>由名称和对应值组成的一个变量对象的属性被创建</li><li>没有实参，属性值为undefined</li></ul></li><li><b>函数</b>声明（也就是<b>函数提升</b>）<ul><li>由名称和对应值（函数对象）组成一个变量对象的属性被创建</li><li>如果变量对象已经存在相同名称的属性，则会覆盖这个属性</li></ul></li><li><b>变量</b>声明（也就是<b>变量提升</b>）<ul><li>由名称和对应值（undefined）组成一个变量对象的属性被创建</li><li>如果变量名称跟已经声明的形参或函数相同，则变量声明不会干扰已经存在的这类属性</li></ul></li></ol><p>举下面这个例子：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(a)</span> &#123;<br>    <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">c</span><span class="hljs-params">()</span> &#123;&#125;<br>    <span class="hljs-keyword">var</span> d = <span class="hljs-keyword">function</span><span class="hljs-params">()</span> &#123;&#125;;<br>    b = <span class="hljs-number">3</span>;<br>&#125;<br><br>foo(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>进入执行上下文后，该上下文的活动对象为：</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">AO = &#123;</span><br><span class="hljs-attribute">    arguments</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#123;</span><br>        <span class="hljs-attribute">0</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1,</span><br>        <span class="hljs-attribute">length</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1</span><br>    <span class="hljs-attribute">&#125;,</span><br><span class="hljs-attribute">    a</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1,</span><br>    <span class="hljs-attribute">b</span><span class="hljs-punctuation">:</span> <span class="hljs-string">undefined,</span><br>    <span class="hljs-attribute">c</span><span class="hljs-punctuation">:</span> <span class="hljs-string">reference to function c()&#123;&#125;,</span><br>    <span class="hljs-attribute">d</span><span class="hljs-punctuation">:</span> <span class="hljs-string">undefined</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h2><p>在代码执行阶段，会顺序执行代码，根据代码修改变量对象的属性值。</p><p>上面的例子进入代码执行后，活动对象会变为：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dts">AO = <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    arguments:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-number">0</span>: <span class="hljs-number">1</span>,<br><span class="hljs-symbol">        length:</span> <span class="hljs-number">1</span><br>    <span class="hljs-punctuation">&#125;</span>,<br><span class="hljs-symbol">    a:</span> <span class="hljs-number">1</span>,<br><span class="hljs-symbol">    b:</span> <span class="hljs-number">2</span>,<br><span class="hljs-symbol">    c:</span> reference to function c()<span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span>,<br><span class="hljs-symbol">    d:</span> reference to FunctionExpression <span class="hljs-string">&quot;d&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="其他例子"><a href="#其他例子" class="headerlink" title="其他例子"></a>其他例子</h2><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(foo);<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;foo&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> foo = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>这个例子，最终会打印函数，因为<b>变量声明时若已有同名的函数或形参声明过，则不会覆盖。</b>所以foo首先声明为一个函数，foo再作为变量想声明时不会覆盖前面的函数，所以打印出来的是函数。</p>]]></content>
    
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>作用域链</title>
    <link href="/2023/04/19/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
    <url>/2023/04/19/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<p>作用域链</p><p>由《执行上下文栈》我们可知JavaScript每执行一段可执行代码时，都会创建对应的执行上下文。</p><p>对于每个执行上下文，都有三个重要属性：</p><ul><li>变量对象</li><li>作用域链</li><li>this</li></ul><p>本篇主要介绍作用域链。</p><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>什么是作用域？作用域是指程序源代码中定义变量的区域。它规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</p><p><b>JavaScript采用词法作用域，也就是静态作用域。</b></p><h1 id="静态作用域与动态作用域"><a href="#静态作用域与动态作用域" class="headerlink" title="静态作用域与动态作用域"></a>静态作用域与动态作用域</h1><p>词法作用域中函数的作用域在<b>函数定义</b>的时候就决定了，而动态作用域是在<b>函数调用</b>的时候才决定的。</p><p>用以下这个例子来说明：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> value = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(value);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> value = <span class="hljs-number">2</span>;<br>    foo();<br>&#125;<br><br>bar();<br><br><span class="hljs-comment">// 输出：？</span><br></code></pre></td></tr></table></figure><p>假设JavaScript采用静态作用域，则执行过程应该如下：<br>执行foo函数 -&gt; 先查找foo函数内部是否有局部变量value -&gt; 没有查找到 -&gt; 因为是静态作用域，在定义时就决定了变量的可访问区域，所以根据书写位置，查找上一层的作用域是否有变量value -&gt; 查找到value为1 -&gt; 打印1。</p><p>假设JavaScript采用动态作用域，则执行过程应该如下：<br>执行foo函数 -&gt; 先查找foo函数内部是否有局部变量 -&gt; 没有查找到 -&gt; 因为是动态作用域，所以从调用函数的作用域，也就是bar函数内部查找 -&gt; 查找到到calue为2 -&gt; 打印2。</p><p>我们可以在控制台尝试一下，可以知道最后打印出来的是1，也就验证了JavaScript采用的是静态作用域。</p><h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><p>在《变量对象》中讲到，当查找变量的时候，会先从当前上下文的变量对象中查找，如果没找到，就会从<b>父级（词法层面的父级）</b>执行上下文的变量对象中查找，一直查找到全局上下文的变量对象，也就是全局变量。</p><p><b>这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</b></p><p>接下来，让我们以一个函数的<b>创建</b>和<b>激活</b>两个时期来讲解作用域链是如何创建和变化的。</p><h2 id="函数创建"><a href="#函数创建" class="headerlink" title="函数创建"></a>函数创建</h2><p>上文 词法作用域和动态作用域 部分有讲到，函数的作用域是在函数定义的时候就决定了。</p><p>这是因为函数内部有一个属性[[scope]]，当函数创建的时候，就会保存父变量对象到其中，我们可以理解[[scope]]就是父变量对象的层级链。</p><blockquote><p>注意：[[scope]]并不代表完整的作用域链！</p></blockquote><p>举个例子，有这样一个函数：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span><span class="hljs-params">()</span> &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个函数创建时，各自的[[scope]]为：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua">foo.<span class="hljs-string">[[scope]]</span> = [<br>    globalContext.VO<br>];<br>bar.<span class="hljs-string">[[scope]]</span> = [<br>    fooContext.AO,<br>    globalContext.VO<br>];<br></code></pre></td></tr></table></figure><h2 id="函数激活"><a href="#函数激活" class="headerlink" title="函数激活"></a>函数激活</h2><p>当函数激活时，进入函数上下文，创建AO和VO后，就会将活动对象添加到作用域的前端。<br>这时候执行上下文的作用域链，假设将它命名为Scope:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">Scope = [AO].CONCACT(<span class="hljs-string">[[Scope]]</span>);<br></code></pre></td></tr></table></figure><p>至此，作用域链创建完毕。</p><h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>以下面例子为例，结合之前讲的变量对象和执行上下文栈，我们来总结一下函数执行上下文中作用域链和变量对象的创建过程。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> scope = “<span class="hljs-keyword">global</span> scope”;<br><span class="hljs-function">function <span class="hljs-title">checkscope</span>()</span> &#123;<br>    <span class="hljs-keyword">var</span> scope2 = <span class="hljs-string">&#x27;local scope&#x27;</span>;<br>    <span class="hljs-keyword">return</span> scope2;<br>&#125;<br>checkscope();<br></code></pre></td></tr></table></figure><p>执行过程如下：</p><ol><li>checkscope函数被创建，保存作用域链到内部属性[[scope]]<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">chekscope.<span class="hljs-string">[[scope]]</span> = [<br>    globalContext.VO<br>];<br></code></pre></td></tr></table></figure></li><li>执行checkscope函数，创建checkscope函数执行上下文，checkscope函数上下文被压入执行上下文栈<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ECStack</span> = [<br>    checkscopeContext,<br>    globalContext<br>]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li><li>checkscope函数并不立刻执行，开始做准备工作。第一步：复制函数[[scope]]属性创建作用域链<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">checkscopeContext = &#123;<br>    Scope: checkscope.<span class="hljs-string">[[scope]]</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>第二步：用arguments创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dts">checkscopeC<span class="hljs-attr">ontext</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    AO:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">        arguments:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">            length:</span> <span class="hljs-number">0</span><br>        <span class="hljs-punctuation">&#125;</span>,<br><span class="hljs-symbol">        scope2:</span> undefined<br>    <span class="hljs-punctuation">&#125;</span>,<br><span class="hljs-symbol">    Scope:</span> checkscope.[[scope]]<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li>第三步：将活动对象压入checkscope作用域链顶端<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dts">checkscopeC<span class="hljs-attr">ontext</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">    AO:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">        arguments:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-symbol">            length:</span> <span class="hljs-number">0</span><br>        <span class="hljs-punctuation">&#125;</span>,<br><span class="hljs-symbol">        scope2:</span> undefined<br>    <span class="hljs-punctuation">&#125;</span>,<br><span class="hljs-symbol">    Scope:</span> [AO, [[Scope]]]<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li>准备工作做完，开始执行函数，随着函数的执行，修改AO的属性值<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua">checkscopeContext = &#123;<br>    AO: &#123;<br>        arguments: &#123;<br>            length: <span class="hljs-number">0</span><br>        &#125;,<br>        scope2: <span class="hljs-string">&#x27;local scope&#x27;</span><br>    &#125;,<br>    Scope: [AO, <span class="hljs-string">[[Scope]]</span>]<br>&#125;<br></code></pre></td></tr></table></figure></li><li>查找到scope2的值，返回后函数执行完毕，函数执行上下文从执行上下文栈中弹出。<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">ECStack</span> <span class="hljs-operator">=</span> [<br>    globalContext<br>]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/mqyqingfeng/Blog/issues/6">https://github.com/mqyqingfeng/Blog/issues/6</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>执行上下文栈</title>
    <link href="/2023/04/19/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/"/>
    <url>/2023/04/19/%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<p>执行上下文栈</p><p>首先我们都知道JavaScript代码是顺序执行，那么具体是怎么做的呢？我们来了解一下作用域和执行上下文。</p><h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p>我们知道JavaScript是顺序执行的，但是又有变量提升和函数提升的机制，这两点为什么不冲突呢？</p><p>因为JavaScript引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会先进行一个“准备工作”，就包括前面所说的变量提升和函数提升。</p><p>但是一段一段地分析，这个“段”是怎么划分的呢？所以我们就要提到JavaScript的可执行代码了。</p><p>JavaScript的可执行性代码分为三种：<b>全局代码、函数代码、eval代码</b>。</p><p>比如当执行到一个函数时，就是一段可执行代码，就会为之创建对应的执行上下文。</p><p>那么因此执行上下文对应也有三种：<b>全局执行上下文、函数执行上下文、eval执行上下文</b>。</p><blockquote><p>eval函数回计算JavaScript字符串，并把它当脚本代码来执行。由于eval函数很少使用，不做介绍。</p></blockquote><h1 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h1><p>我们知道，实际的工作项目中，函数的数量非常多，每个函数都会创建一个执行上下文，那怎么管理创建的那么多执行上下文呢？</p><p>因此JavaScript引擎创建了<b>执行上下文栈</b>来管理执行上下文。</p><p>我们暂且将执行上下文栈定义为一个数组，来模拟执行上下文栈的行为。假设执行上下文栈是数组ECStack：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var ECStack <span class="hljs-operator">=</span> []<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>当JavaScript开始解析执行代码的时候，最先遇到的肯定是全局代码，所以最开始首先会向执行上下文栈押入一个全局执行上下文，假设用globalContext来表示它，只有当整个应用程序结束的时候，ECStack才会被清空，因此在清空钱，ECStack最底部一直都会是globalContext。</p><p>当执行一个函数的时候，就会创建一个执行上下文，并且推入执行上下文栈，当函数执行完毕时，就会将函数的执行上下文从栈中弹出。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs scss">function <span class="hljs-built_in">fun3</span>() &#123;<br>    console<span class="hljs-selector-class">.log</span>(&#x27;func3&#x27;);<br>&#125;<br><br>function <span class="hljs-built_in">fun2</span>() &#123;<br>    <span class="hljs-built_in">fun3</span>();<br>&#125;<br><br>function <span class="hljs-built_in">fun1</span>() &#123;<br>    <span class="hljs-built_in">fun2</span>();<br>&#125;<br><br><span class="hljs-built_in">fun1</span>();<br></code></pre></td></tr></table></figure><p>我们用以上这段代码来模拟以下执行上下文栈进出栈的过程：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 伪代码<br><br><span class="hljs-regexp">//</span> 首先推入全局上下文<br>ECStack.push(globalContext);<br><br><span class="hljs-regexp">//</span> ...其他代码<br><br><span class="hljs-regexp">//</span> 执行fun1()<br>ECStack.push(&lt;fun1&gt; functionContext);<br><br><span class="hljs-regexp">//</span> fun1中调用了fun2<br>ECStack.push(&lt;fun2&gt; functionContext);<br><br><span class="hljs-regexp">//</span> fun2中调用了fun3<br>ECStack.push(&lt;fun3&gt; functionContext);<br><br><span class="hljs-regexp">//</span> fun3执行完毕<br>ECStack.pop();<br><br><span class="hljs-regexp">//</span> fun2执行完毕<br>ECStack.pop();<br><br><span class="hljs-regexp">//</span> fun1执行完毕<br>ECStack.pop();<br><br><span class="hljs-regexp">//</span> ...接着执行其他代码<br><br><span class="hljs-regexp">//</span> 整个应用程序结束的时候，最后推出全局上下文<br>ECStack.pop();<br></code></pre></td></tr></table></figure><h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>从以下两个例子，我们可以很容易看到执行上下文栈变化的不一样。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 例子1</span><br><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkscope</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;local scope&quot;</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> scope;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f();<br>&#125;<br>checkscope();<br></code></pre></td></tr></table></figure><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 例子2</span><br><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;global scope&quot;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkscope</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&quot;local scope&quot;</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> scope;<br>    &#125;<br>    <span class="hljs-keyword">return</span> f;<br>&#125;<br>checkscope()();<br></code></pre></td></tr></table></figure><p>我们可以通过模拟的方式看到执行上下文栈变化的不同：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 例子2</span><br>ECStack.<span class="hljs-built_in">push</span>(&lt;checkscope&gt; functionContext);<br>ECStack.<span class="hljs-built_in">push</span>(&lt;f&gt; functionContext);<br>ECStack.<span class="hljs-built_in">pop</span>();<br>ECStack.<span class="hljs-built_in">pop</span>();<br></code></pre></td></tr></table></figure><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 例子2</span><br>ECStack.<span class="hljs-built_in">push</span>(&lt;checkscope&gt; functionContext);<br>ECStack.<span class="hljs-built_in">pop</span>();<br>ECStack.<span class="hljs-built_in">push</span>(&lt;f&gt; functionContext);<br>ECStack.<span class="hljs-built_in">pop</span>();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>继承</title>
    <link href="/2023/04/17/%E7%BB%A7%E6%89%BF/"/>
    <url>/2023/04/17/%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>原型链</title>
    <link href="/2023/04/15/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <url>/2023/04/15/%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<p>原型链</p><p>以以下一个简单的例子入手：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span><span class="hljs-params">()</span> &#123;<br><br>&#125;<br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person();<br></code></pre></td></tr></table></figure><h1 id="构造函数与实例对象"><a href="#构造函数与实例对象" class="headerlink" title="构造函数与实例对象"></a>构造函数与实例对象</h1><p>在上述例子中，<code>Person</code>就是一个构造函数，<code>person</code>就是使用new实例化出来的一个实例对象。</p><p><img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE/1.png" alt="1"></p><h1 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h1><p>每个函数都有一个prototype属性，我们经常看到如下的例子：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;<br>Person.prototyoe.name = <span class="hljs-string">&#x27;TOM&#x27;</span>;<br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-keyword">var</span> person2 = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(person1.name); <span class="hljs-comment">// TOM</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(person2.name); <span class="hljs-comment">// TOM</span><br></code></pre></td></tr></table></figure><p>注意：<b>prototype是函数才会有的属性。</b>那这个prototype到底指向了什么呢？</p><p>其实，<b>函数的prototype属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型。</b>即这个例子中，Person的prototype也就是person1和person2的原型。</p><p>那什么是原型呢？可以这样理解：<b>每一个JavaScript对象（null除外）在创建的时候都会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型继承属性。</b></p><p>可以用以下这张图来表示构造函数和实例原型之间的关系：</p><p><img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE/2.png" alt="2"></p><p>如上图，Person是构造函数，我们用Person.prototype表示实例原型。那我们该怎么表示实例与实例原型，也就是person与Person.prototype间的关系呢？这时候我们需要介绍第二个属性：_proto_。</p><h1 id="proto"><a href="#proto" class="headerlink" title="proto"></a><em>proto</em></h1><p><b>每一个JavaScript对象（除了null）都具有一个对象，叫_proto_，这个属性会指向该对象的原型，也就是实例化该对象出来的构造函数的prototype。</b><br>我们可以通过以下例子证明这一点：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;<br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(person._proto_ === Person.prototype); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>于是我们可以更新关系图如下：</p><p><img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE/3.png" alt="3"></p><p>既然实例对象和构造函数都可以指向实例原型，那么实例原型可以指向实例对象和构造函数吗？</p><p>从原型到实例对象的指向是没有的，因为一个构造函数可以生成多个实例。但是原型可以指向构造函数，这里需要介绍第三个属性：constructor。</p><h1 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h1><p>每一个原型都有一个constructor属性指向关联的的构造函数。我们可以通过以下例子证明这一点：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(Person.prototype.constructor === Person); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>于是我们可以更新关系图如下：</p><p><img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE/4.png" alt="4"></p><p>综上，我们了解了构造函数、实例原型、实例三者之间的关系，接下来了解以下实例和原型之间的关系。</p><h1 id="实例与原型"><a href="#实例与原型" class="headerlink" title="实例与原型"></a>实例与原型</h1><p><b>当读取实例的属性时，如果找不到，就会查找与实例对象关联的原型中的属性，如果还是找不到，就会向上去找原型的原型，一直找到最顶层为止。</b>我们可以看以下的例子：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br><br>&#125;<br>Person.prototype.name = <span class="hljs-string">&#x27;Tom&#x27;</span>;<br><br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person();<br><br>person.name = <span class="hljs-string">&#x27;Jack&#x27;</span>;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(person.name); <span class="hljs-comment">// Jack</span><br><br>delete person.name;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(person.name); <span class="hljs-comment">// Tom</span><br></code></pre></td></tr></table></figure><p>在以上示例中，我们给实例对象person添加了name属性，当我们打印person.name时，自然打印的是person的name属性值’Jack’。</p><p>但是当我们删除person的name属性后，再读取person.name，从person对象中找不到name属性就会从person的原型也就是person._proto_，也就是Person.prototype中查找，于是打印出来的是Person.prototype的name属性值’Tom’。</p><p>同样的，当我们获取preson.constructor时，其实person中并没有constructor属性，当查找不到时，就会从person的原型也就是Person.prototype中读取，即：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">person.constrcutor <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> Person.prototype.constructor <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> Person<br></code></pre></td></tr></table></figure><p>那如果person的原型也就是person._proto_中没找到呢？原型的原型又是什么？</p><h1 id="原型的原型"><a href="#原型的原型" class="headerlink" title="原型的原型"></a>原型的原型</h1><p>前面我们说到函数的prototype指向一个对象，也就是原型也是一个对象。既然是对象，我们就可以用原始的Object构造函数创建它：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> Object();<br>obj.name = <span class="hljs-string">&#x27;TOM&#x27;</span>;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(obj.name); <span class="hljs-comment">// TOM</span><br></code></pre></td></tr></table></figure><p>其实原型对象就是通过Object函数创建出来的，结合之前说的实例的_proto_指向构造函数的prototype，所以原型的_proto_就指向Object的prototype。</p><p>我们可以更新关系图如下：</p><p><img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE/5.png" alt="5"></p><h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><p>原型的原型是Object.prototype，那么Object.prototype的原型是什么呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_proto_</span>); <span class="hljs-comment">// null</span><br></code></pre></td></tr></table></figure><p>由上可见，Object.prototype的原型是null。</p><blockquote><p>null表示“没有对象”，即该处不该有值。 – 阮一峰《undefined与null的区别》</p></blockquote><p>所以我们可以理解为：Object.prototype._proto_的值为null，也就是说Object.prototype没有原型。</p><p>所以查找属性的时候，查到Object.prototype就可以停止查找了。我们可以更新关系图如下：</p><p><img src="/images/%E5%8E%9F%E5%9E%8B%E9%93%BE/6.png" alt="6"></p><p>我们常说的<b>原型链就是由相互关联的原型组成的链状结构</b>，也就是图中蓝色的这条线。</p><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p>参考：<a href="https://github.com/mqyqingfeng/Blog/issues/2">https://github.com/mqyqingfeng/Blog/issues/2</a></p><h1 id="相关扩展点"><a href="#相关扩展点" class="headerlink" title="相关扩展点"></a>相关扩展点</h1><p>new<br>继承</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目经验</title>
    <link href="/2023/02/15/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C/"/>
    <url>/2023/02/15/%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="项目经验"><a href="#项目经验" class="headerlink" title="项目经验"></a>项目经验</h1><h2 id="一、npm引入双包做实验"><a href="#一、npm引入双包做实验" class="headerlink" title="一、npm引入双包做实验"></a>一、npm引入双包做实验</h2><p>可引入一个包的不同版本做AB实验，实验内使用新包，实验外使用旧包</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-string">&quot;package&quot;</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>,<br><span class="hljs-string">&quot;package-new&quot;</span>: <span class="hljs-string">&quot;npm:package@1.0.1&quot;</span>,<br></code></pre></td></tr></table></figure><h2 id="二、动态引入外部包：import和import"><a href="#二、动态引入外部包：import和import" class="headerlink" title="二、动态引入外部包：import和import()"></a>二、动态引入外部包：import和import()</h2><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p><code>import</code>语句会被js引擎静态分析，先于模块内的其他模块执行。所以，下面这种代码会报错</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">if</span> (x === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">import</span> otherMoudle <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./otherMoudle&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>引擎处理<code>import</code>语句是在编译时，而if语句这类是运行时处理，所以<code>import</code>语句放在if代码块内会报语法错误。也就是说<code>import</code>和<code>export</code>命令只能在模块的顶层，而不能在代码块之中。</p><p>这样设计有助于提高编译效率，但也导致无法在运行时加载模块，即不能根据业务条件加载，可能会导致包体积过大。因此引入import()函数，支持动态加载。</p><h3 id="import-1"><a href="#import-1" class="headerlink" title="import()"></a>import()</h3><p><code>import()</code>类似node中的require，是在运行时加载模块，即可以实现动态加载。区别主要在于<code>import()</code>是<code>异步加载</code>，<code>require</code>是<code>同步加载</code>;</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;sdkPackage&#x27;</span>).then(sdk =&gt; &#123;<br>    <span class="hljs-keyword">const</span> sdkInstanse = <span class="hljs-keyword">new</span> sdk.<span class="hljs-keyword">default</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><p>ES6 import()返回一个Promise对象，以上是一个例子。<code>import()</code>函数可以用在任何地方，不仅仅是模块，也可以是非模块的脚本。下面是<code>import()</code>的一些适用场合。</p><h4 id="（1）按需加载"><a href="#（1）按需加载" class="headerlink" title="（1）按需加载"></a>（1）按需加载</h4><p>import()可以在需要的时候在加载某个模块</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dart">button.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, event =&gt; &#123;<br>    <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./dialogBox.js&#x27;</span>).then(dialogBox =&gt; &#123;<br>        dialogBox.open();<br>    &#125;).<span class="hljs-keyword">catch</span>(error =&gt; &#123;<br>        <span class="hljs-comment">/* Error handling */</span><br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>比如以上代码，<code>import()</code>方法放在click事件的监听函数中，只有用户点击了按钮才会加载这个模块。</p><h4 id="（2）条件加载"><a href="#（2）条件加载" class="headerlink" title="（2）条件加载"></a>（2）条件加载</h4><p><code>import()</code>可以放在if等代码块中，根据不同的条件加载不同的模块。</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">if</span> (condition) &#123;<br>    <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;moduleA&#x27;</span>).then(<span class="hljs-params">...</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;moduleB&#x27;</span>).then(<span class="hljs-params">...</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，根据是否满足condition，条件加载模块A或者模块B。</p><h4 id="（3）动态的模块路径"><a href="#（3）动态的模块路径" class="headerlink" title="（3）动态的模块路径"></a>（3）动态的模块路径</h4><p><code>import()</code>加载的内容可以是动态生成的路径。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">import</span>(fn())<span class="hljs-selector-class">.then</span>(...);<br></code></pre></td></tr></table></figure><p>上面代码中，import()的内容是一个函数，可以根据函数fn的返回结果，加载不同的模块。</p>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>踩坑记录</title>
    <link href="/2022/11/17/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/11/17/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>常用工具</p><h1 id="css动画"><a href="#css动画" class="headerlink" title="css动画"></a>css动画</h1><p>卡顿：尽量避免使用margin、padding、left、right等来transform，更推荐使用translate、scale</p><h1 id="二维码解析"><a href="#二维码解析" class="headerlink" title="二维码解析"></a>二维码解析</h1><p>个别解析失败问题：todo</p>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css经验</title>
    <link href="/2022/11/04/css%E7%BB%8F%E9%AA%8C/"/>
    <url>/2022/11/04/css%E7%BB%8F%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="css经验"><a href="#css经验" class="headerlink" title="css经验"></a>css经验</h1><h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h2><p>css渐变属性：linear-gradient</p><h3 id="渐变抗锯齿"><a href="#渐变抗锯齿" class="headerlink" title="渐变抗锯齿"></a>渐变抗锯齿</h3><p>锯齿现象：锯齿现象在DPR为1（如ios）的屏幕下特别明显，在dpr&gt;1的高清屏上则相较不明显。<br>锯齿产生原因：网页呈现是基于像素单位的，在一种颜色直接过渡到另外一种颜色时，容易导致可视质量下降。</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(<span class="hljs-number">37deg</span>), <span class="hljs-number">#000</span> <span class="hljs-number">50%</span>, <span class="hljs-number">#f00</span> <span class="hljs-number">50%</span>, <span class="hljs-number">#f00</span>);<br></code></pre></td></tr></table></figure><p>比如以上代码在50%的地方从#000直接过渡到#f00，仔细看即可看到过渡处的锯齿。<br><img src="/images/css%E7%BB%8F%E9%AA%8C/1.png" alt="1"></p><h3 id="简单的解决方法"><a href="#简单的解决方法" class="headerlink" title="简单的解决方法"></a>简单的解决方法</h3><p>最简单的就是<b>不要直接过渡</b>。将上述代码从50%-50%的直接过渡，改成预留了1%的渐变过渡空间</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">background</span>: linear-gradient(<span class="hljs-number">37</span>deg), #<span class="hljs-number">000</span> <span class="hljs-number">49</span>.<span class="hljs-number">5</span>%, #f00 <span class="hljs-number">49</span>.<span class="hljs-number">5</span>%, #f00);<br></code></pre></td></tr></table></figure><p>即可有效处理过渡处的锯齿问题。改造后效果如下：<br><img src="/images/css%E7%BB%8F%E9%AA%8C/2.png" alt="2"></p><h2 id="css实现文字滚动"><a href="#css实现文字滚动" class="headerlink" title="css实现文字滚动"></a>css实现文字滚动</h2><p>css属性： animation、@keyframes、transform</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">set<span class="hljs-constructor">Animation()</span> &#123;<br>    this.<span class="hljs-constructor">$nextTick(()</span> =&gt; &#123;<br>        const textDom = this.$refs.text;<br>        const canScroll = textDom?.clientWidth &lt; textDom?.scrollWidth;<br>        <span class="hljs-keyword">if</span> (canScroll) &#123;<br>            const styleEl = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">style</span>&#x27;)</span>;<br>            styleEl.id = &#x27;textKeyframe&#x27;;<br>            document.head.append<span class="hljs-constructor">Child(<span class="hljs-params">styleEl</span>)</span>;<br>            const textKeyframe = `<br>                @keyframes wordsLoop &#123;<br>                    <span class="hljs-number">0</span>% &#123;<br>                        transform: translate<span class="hljs-constructor">X(0px)</span><br>                    &#125;<br>                    <span class="hljs-number">10</span>% &#123;<br>                        transform: translate<span class="hljs-constructor">X(0px)</span>;<br>                    &#125;<br>                    <span class="hljs-number">90</span>% &#123;<br>                        transform: translate<span class="hljs-constructor">X($&#123;<span class="hljs-params">textDom</span>?.<span class="hljs-params">clientWidth</span> - <span class="hljs-params">textDom</span>?.<span class="hljs-params">scrollWidth</span>&#125;<span class="hljs-params">px</span>)</span><br>                    &#125;<br>                    <span class="hljs-number">100</span>% &#123;<br>                        transform: translate<span class="hljs-constructor">X($&#123;<span class="hljs-params">textDom</span>?.<span class="hljs-params">clientWidth</span> - <span class="hljs-params">textDom</span>?.<span class="hljs-params">scrollWidth</span>&#125;<span class="hljs-params">px</span>)</span><br>                    &#125;<br>                &#125;<br>            `;<br>            styleEl.sheet.insert<span class="hljs-constructor">Rule(<span class="hljs-params">textKeyframe</span>, 0)</span>;<br>            this.appTextStyle = &#123;<br>                animation: &#x27;wordsLoop <span class="hljs-number">3</span>s linear alternate infinite&#x27;,<br>                &#x27;-webkit-animation&#x27;: &#x27;wordsLoop <span class="hljs-number">3</span>s linear alternate infinite&#x27;<br>            &#125;;<br>        &#125;<br>    &#125;);<br>&#125;,<br></code></pre></td></tr></table></figure><p>滚动的核心动画为@keyframes部分，是否要用动态插入的方式具体要看滚动的规则是怎样的。如果需要根据文本长度动态计算，则可能需要使用动态插入的方式。</p><h3 id="动态插入个别机型不兼容问题"><a href="#动态插入个别机型不兼容问题" class="headerlink" title="动态插入个别机型不兼容问题"></a>动态插入个别机型不兼容问题</h3><p>如果动态插入的动画在个别机型上不动，需要格外注意该<b>动画样式被使用时是不是已经存在</b>。<br>比如上述代码，是先生成了wordsLoop这个keyframes并插入到样式表之后，再通过appTextStyle使用了wordsLoop。使用wordsLoop时wordsLoop是已经存在样式表中的。<br>如果将appTextStyle中的animation部分直接写在css文件中，那么代码初始运行时，wordsLoop还未生成，样式表中还没有该keyframes。即便后面生成插入了，但可能在有的机型上会不兼容不能展示动画。</p>]]></content>
    
    
    <categories>
      
      <category>css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图片引入与iconfont使用</title>
    <link href="/2022/10/12/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/10/12/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="图片引入与iconfont使用"><a href="#图片引入与iconfont使用" class="headerlink" title="图片引入与iconfont使用"></a>图片引入与iconfont使用</h1><h2 id="图片引入"><a href="#图片引入" class="headerlink" title="图片引入"></a>图片引入</h2><p>日常项目开发中，通常ue图中用到的图片ue会给我们切图，我们需要把图使用到代码中，通常使用的引入图片方式有：</p><ol><li>把图片放到代码库的静态资源中。<ul><li>优点：打包进产出，加载后运行时显示快</li><li>缺点：增大打包体积，影响包加载速度</li></ul></li><li>图片上传cdn，生成cdn链接使用url引入<ul><li>优点：可以替换cdn资源来更换图片内容，可以根据拦截器进行权限控制，可以缓存，不影响包体积情况下加载速度也很不错，是最常用的方式</li><li>缺点：需要考虑一些特殊场景，比如svg图片通过url引入使用image标签时，在ios上会很模糊</li></ul></li><li>图标类通过iconfont转base64使用<ul><li>优点：减少图片的http请求</li><li>缺点：base64相当于把字符串直接写在代码文件中，也会增加代码打包体积，一般只在加载小图标时使用</li></ul></li></ol><h2 id="iconfont使用"><a href="#iconfont使用" class="headerlink" title="iconfont使用"></a>iconfont使用</h2><h3 id="1-将要使用的图片上传至iconfont"><a href="#1-将要使用的图片上传至iconfont" class="headerlink" title="1.将要使用的图片上传至iconfont"></a>1.将要使用的图片上传至iconfont</h3><p><img src="/images/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/1.png" alt="1"><br>上传时可能需要几分钟审核，等待一段时间即可</p><h3 id="2-下载图标代码"><a href="#2-下载图标代码" class="headerlink" title="2.下载图标代码"></a>2.下载图标代码</h3><p>审核通过成功上传后，将图标添加进购物车，然后进购物车下载代码<br><img src="/images/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/2.png" alt="2"></p><p><img src="/images/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/3.png" alt="3"></p><h3 id="3-获取iconfont代码文件"><a href="#3-获取iconfont代码文件" class="headerlink" title="3.获取iconfont代码文件"></a>3.获取iconfont代码文件</h3><p>下载成功后，得到一个压缩文件，解压如下<br><img src="/images/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/4.png" alt="4"></p><h3 id="4-将下载的tff文件转换为base64格式"><a href="#4-将下载的tff文件转换为base64格式" class="headerlink" title="4.将下载的tff文件转换为base64格式"></a>4.将下载的tff文件转换为base64格式</h3><p>推荐使用网站：<a href="https://transfonter.org/">https://transfonter.org</a></p><p>按下图配置选项，打开 Base64 encode 选项：<br><img src="/images/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/5.png" alt="5"></p><p>配置完后，添加tff文件，开始转换<br><img src="/images/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/6.png" alt="6"></p><p>转换成功后，点击下载<br><img src="/images/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/7.png" alt="7"></p><p>下载得到压缩文件，解压后会有一个stylesheet.css的css文件<br><img src="/images/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/8.png" alt="8"></p><p>该css文件的字体地址就是base64了<br><img src="/images/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/9.png" alt="9"></p><h3 id="5-在项目中使用"><a href="#5-在项目中使用" class="headerlink" title="5.在项目中使用"></a>5.在项目中使用</h3><p>将上一步得到的css文件代码中的@font-face部分复制至代码中<br>以及第3步iconfont上下载得到的iconfont.css文件中的样式部分复制至代码中<br>最后项目里的css文件如下：<br><img src="/images/%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5%E4%B8%8Eiconfont%E4%BD%BF%E7%94%A8/10.png" alt="10"></p><p>使用的地方：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;iconfont icon-back&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Reference-Document"><a href="#Reference-Document" class="headerlink" title="Reference Document"></a>Reference Document</h2><p><a href="https://www.tytrock.com/topics/327">阿里巴巴 iconfont 字体转 base64 并引入使用</a></p>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack入门</title>
    <link href="/2022/10/11/webpack%E5%85%A5%E9%97%A8/"/>
    <url>/2022/10/11/webpack%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p>1.生成package.json文件</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> init<br></code></pre></td></tr></table></figure><p>2.安装webpack</p>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2022/10/11/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2022/10/11/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<p>二分查找</p><h1 id="基本二分查找"><a href="#基本二分查找" class="headerlink" title="基本二分查找"></a>基本二分查找</h1><h1 id="二分查找要点"><a href="#二分查找要点" class="headerlink" title="二分查找要点"></a>二分查找要点</h1><h2 id="如何确定循环结束条件"><a href="#如何确定循环结束条件" class="headerlink" title="如何确定循环结束条件"></a>如何确定循环结束条件</h2><h2 id="区间如何收缩"><a href="#区间如何收缩" class="headerlink" title="区间如何收缩"></a>区间如何收缩</h2><h2 id="如何确定返回值"><a href="#如何确定返回值" class="headerlink" title="如何确定返回值"></a>如何确定返回值</h2><h2 id="Reference-Document"><a href="#Reference-Document" class="headerlink" title="Reference Document"></a>Reference Document</h2><p><a href="https://www.cnblogs.com/labuladong/p/12320448.html">https://www.cnblogs.com/labuladong/p/12320448.html</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用工具</title>
    <link href="/2022/10/08/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    <url>/2022/10/08/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<p>常用工具</p><h1 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h1><p>npm包查询：<a href="https://bundlephobia.com/">https://bundlephobia.com/</a><br>npm包比较：<a href="https://npmtrends.com/">https://npmtrends.com/</a></p><h1 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h1>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用命令</title>
    <link href="/2022/10/08/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/10/08/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>常用命令</p><h1 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h1><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">npm cache clean -f <span class="hljs-regexp">//</span> 清除npm缓存<br></code></pre></td></tr></table></figure><h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1>]]></content>
    
    
    <categories>
      
      <category>前端开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用js移位运算符取整</title>
    <link href="/2022/09/28/%E4%BD%BF%E7%94%A8js%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%96%E6%95%B4/"/>
    <url>/2022/09/28/%E4%BD%BF%E7%94%A8js%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8F%96%E6%95%B4/</url>
    
    <content type="html"><![CDATA[<p>使用js移位运算符取整</p><h1 id="运算符介绍"><a href="#运算符介绍" class="headerlink" title="运算符介绍"></a>运算符介绍</h1><h2 id="有符号右移"><a href="#有符号右移" class="headerlink" title="有符号右移"></a>有符号右移</h2><p><code>&gt;&gt;</code>该操作符会将指定操作数的二进制位向右移动指定的位数。<b>向右被移出的位被丢弃，拷贝最左侧的位以填充左侧。</b>由于新的最左侧的位总是和以前相同，符号位没有被改变。</p><h2 id="无符号右移"><a href="#无符号右移" class="headerlink" title="无符号右移"></a>无符号右移</h2><p><code>&gt;&gt;&gt;</code>该操作符会将第1个操作数向右移动指定的位数。<b>向右被移出的位被丢弃，左侧用0填充。</b>因为符号位变成了0，所以结果总是非负的.</p><h1 id="妙用"><a href="#妙用" class="headerlink" title="妙用"></a>妙用</h1><h2 id="用于取整"><a href="#用于取整" class="headerlink" title="用于取整"></a>用于取整</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">console</span>.log(<span class="hljs-number">3</span>.<span class="hljs-number">14</span> &gt;&gt; <span class="hljs-number">0</span>)  // <span class="hljs-number">3</span><br><span class="hljs-attribute">console</span>.log(<span class="hljs-number">3</span>.<span class="hljs-number">14</span> &gt;&gt;&gt; <span class="hljs-number">0</span>)  // <span class="hljs-number">3</span> (不可对负数取整)<br></code></pre></td></tr></table></figure><h2 id="用于获取除2之后的整数"><a href="#用于获取除2之后的整数" class="headerlink" title="用于获取除2之后的整数"></a>用于获取除2之后的整数</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">console</span>.log(<span class="hljs-number">5</span> &gt;&gt; <span class="hljs-number">1</span>)  // <span class="hljs-number">2</span><br><span class="hljs-attribute">console</span>.log(<span class="hljs-number">4</span> &gt;&gt; <span class="hljs-number">1</span>)  // <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2022/07/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/07/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>设计模式的分类及应用</p><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h1 id="订阅发布模式"><a href="#订阅发布模式" class="headerlink" title="订阅发布模式"></a>订阅发布模式</h1>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/07/22/hello-world/"/>
    <url>/2022/07/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>This website is designed by hexo &amp; fluid, please refer to the following documents for how to use it.</p><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info:<br><a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a><br><a href="https://blog.csdn.net/yaorongke/article/details/119089190">Reference Document</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
